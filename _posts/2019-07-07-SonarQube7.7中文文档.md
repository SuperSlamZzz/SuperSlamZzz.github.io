---
layout: post
title: "SonarQube7.7中文文档（官方文档翻译）"
date: 2019-08-07 10:00:00
image: 'https://res.cloudinary.com/dm7h7e8xj/image/upload/c_fill,h_399,w_760/v1501268554/sunrise_ttb9nk.jpg'
description: SonarQube中文文档.
category: 'sonar'
tags:
- sonar
twitter_text: SonarQube中文文档。
introduction: 文档内容来源于SonarQube7.7官方英文文档，由有道翻译工具翻译。
---

[TOC]
# SonarQube7.7官方文档
中文译文

## 1 架构和集成
### 1.1 概述
SonarQube平台由4个组件组成：
 ![alt sonar-zucheng](https://superslamzzz.github.io/assets/img/SonarQube7.7中文文档/sonar-zucheng.png)

* 一个SonarQube服务器启动3个主要进程：
    * Web服务器，供开发人员、管理人员浏览质量快照并配置SonarQube实例
    * 基于Elasticsearch的搜索服务器支持从UI进行搜索
    * 计算引擎服务器负责处理代码分析报告并将其保存在SonarQube数据库中
* 一个SonarQube数据库存储：
    * SonarQube实例的配置(安全性、插件设置等)
    * 项目、视图等的质量快照。
* 在服务器上安装多个SonarQube插件，可能包括语言、SCM、集成、身份验证和管理插件
### 1.2 集成
下面的模式展示了SonarQube如何与其他ALM工具集成，以及SonarQube的各种组件在哪里使用。
 
* 开发人员在ide中编写代码，并使用SonarLint运行本地分析。
* 开发人员将他们的代码提交到他们最喜欢的SCM工具： git、SVN、TFVC、…
* 持续集成服务器触发自动构建，执行需要运行SonarQube分析的SonarScanner。
* 分析报告被发送到SonarQube服务器进行处理。
* SonarQube服务器处理并将分析报告结果存储在SonarQube数据库中，并在前端页面显示报告结果。
* 开发人员通过SonarQube UI审查、评论和质疑他们的问题，以管理和减少他们的技术债务。
### 1.3 关于机器和位置
* SonarQube平台不能有一个以上的SonarQube服务器和一个以上的SonarQube数据库。
* 为了获得最佳性能，每个组件(服务器、数据库、扫描器)都应该安装在单独的机器上，并且服务器机器应该是专用的。
* SonarScanner可以通过添加机器进行伸缩。
* 所有机器的时间必须同步。
* SonarQube服务器和SonarQube数据库必须位于同一网络中。
* sonarscanner不需要与SonarQube服务器位于同一网络。
* sonarscanner和SonarQube数据库之间没有通信。

## 2 安装需求依赖
### 2.1 先决条件和概述
#### 2.1.1 先决条件
运行SonarQube的唯一先决条件就是在你的机器安装好JAVA（Oracle JRE 8 或者OpenJDK 8）
注意：在Mac OS X上，强烈建议安装Oracle JDK 8而不是相应的Oracle JRE，因为JRE安装没有完全正确地设置Java环境。更多信息请参见这篇文章（https://stackoverflow.com/questions/15624667/mac-osx-java-terminal-version-incorrect）。

#### 2.1.2 硬件条件

- SonarQube服务器的小型(个人或小型团队)实例需要至少2GB的RAM才能高效运行，操作系统需要1GB的空闲RAM。如果您正在为大型团队或企业安装实例，请考虑下面的附加建议。
- 您需要的磁盘空间大小将取决于使用SonarQube分析的代码数量。举个例子，SonarCloud是SonarQube的公共实例，它有超过3.5亿行代码在分析中，已有5年的历史。SonarCloud目前运行在集群化的Amazon EC2 m5上。每个节点分配50Gb驱动器空间的大型实例。它处理19000多个项目，大约有1400万未解决的问题。SonarCloud运行在PostgreSQL 9.5上，它为数据库提供了大约250Gb的磁盘空间。
- SonarQube必须安装在具有良好读写性能的硬盘上。最重要的是，“data”文件夹包含Elasticsearch索引，当服务器启动并运行时，将在这些索引上执行大量I/O。因此，良好的读写硬盘驱动器性能将对SonarQube服务器的整体性能产生重大影响。
- SonarQube在服务器端不支持32位系统。然而，SonarQube在扫描器端支持32位系统。

##### 2.1.2.1 企业的硬件建议
对于大型团队或企业规模的SonarQube安装，需要额外的硬件。在企业级别，监视SonarQube实例/实例管理/java进程内存非常重要，并且应该随着实例的增长指导进一步的硬件升级。启动配置至少应包括：

- 8核心，允许主SonarQube平台运行多个计算引擎。
- 额外需要16GB内存，有关数据库和弹性搜索的额外要求和建议，请参阅以上硬件条件说明。

#### 2.1.3 支持的平台
##### 2.1.3.1 JAVA
SonarQube Java analyzer能够分析任何类型的Java源文件，无论它们遵循的是什么版本的Java。

但是SonarQube分析和SonarQube服务器需要特定版本的JVM。

我们建议使用关键路径更新版本(CPU)。
Java支持情况如下：

 Oracle JRE | 不支持9 
 -|-
  |支持8
 |不支持7
Open JDK|不支持9
|支持8
|不支持7
IBM JRE|不支持
GCJ|不支持
Oracle JRockit|不支持

数据库支持情况如下：

PostgreSQL|支持 9.3-9.6
:-|:-
    |支持 10
    |必须设置为使用UTF-8 字符集
Microsoft SQL Server |不支持 2012（MSSQL Server 11.0）
    |支持 2014（MSSQL Server 12.0）与配套的Microsoft JDBC driver，支持Express Edition。
    |支持 2016（MSSQL Server 13.0）与配套的Microsoft JDBC driver，支持Express Edition。
    |支持 2017（MSSQL Server 14.0）与配套的Microsoft JDBC driver，支持Express Edition。
    |注意：排序必须区分大小写(CS)和区分重音(AS)(例如:Latin1GeneralCS_AS)
    |注意：READCOMMITTEDSNAPSHOT必须在SonarQube数据库上设置，以避免在重载下可能出现的死锁。
    |同时支持Windows身份验证(“集成安全性”)和SQL Server身份验证。有关配置身份验证的说明，请参阅安装/安装/安装服务器页面中的Microsoft SQL Server部分。
[Oracle](http://www.oracle.com/database/) | 不支持 10G
    |支持 11G以及向后兼容的Oracle 12.2.x驱动程序。
    |支持 12C与Oracle 12.2.x驱动程序
    |支持 XE版本
    |注意：必须配置为使用utf8族字符集(请参阅NLS_CHARACTERSET)
    |注意：不支持驱动程序ojdbc14.jar
    |注意：只支持thin模式，不支持OCI
[MySQL](https://www.mysql.com/)不推荐用于大型实例|支持 5.6
    |支持 5.7
    |注意：必须配置为使用UTF8字符集和区分大小写的排序规则
    |注意：只支持InnoDB存储引擎，不支持MyISAM
    |注意：只支持绑定的mysql-connector-java jar包驱动

#####2.1.3.2浏览器
要获得SonarQube提供的完整体验，必须在浏览器中启用JavaScript。

IE|不支持 IE9
:-|:-
    |不支持 IE10
    |支持 IE11
Microsoft Edge  |支持最新版
Firefox |支持最新版
Chrome  |支持最新版
Opera   |未测试过
Safari  |支持最新版

##### 2.1.3.3 GitHub企业集成
要将Pull Request analysis添加到GitHub Enterprise中的check中，必须运行GitHub Enterprise version 2.14+。

##### 2.1.3.4 平台笔记
###### 2.1.3.4.1 Linux
如果您在Linux上运行，您必须确保：

- vm.max_map_count 参数必须大于或等于262144；
- fs.file-max 参数必须大于或等于65536；
- 运行SonarQube服务的用户可以打开至少65536个文件描述符；
- 运行SonarQube的用户可以打开至少2048个线程；

可以使用以下命令查看值：

> sysctl vm.max_map_count  
> sysctl fs.file-max  
> ulimit -n  
> ulimit -u  

可以通过以root用户身份运行以下命令，为当前会话动态设置它们:

> sysctl -w vm.max_map_count=262144  
> sysctl -w fs.file-max=65536  
> ulimit -n 65536  
> ulimit -u 2048  

要更持久地设置这些值，必须更新/etc/sysctl.d/99-sonarqube.conf(或/etc/sysctl.conf，按照你的本地配置)来反映这些值。  
如果运行SonarQube(在本例中为SonarQube)的用户没有权限拥有至少65536个打开描述符，则必须将这一行插入/etc/security/ limited .d/99- SonarQube .conf(或/etc/security/ limited .conf)：

> sonarqube   -   nofile   65536  
> sonarqube   -   nproc    2048  

您可以在[Elasticsearch](https://www.elastic.co/guide/en/elasticsearch/reference/5.6/system-config.html) 文档中获得更多细节。  
如果您使用systemd启动SonarQube，您必须在[service]部分的单元文件中指定这些限制:

> [Service]  
> ...  
> LimitNOFILE=65536  
> LimitNPROC=2048  
> ...  

###### 2.1.3.4.2 seccomp过滤器
默认情况下，Elasticsearch使用[seccomp过滤器](https://www.kernel.org/doc/Documentation/prctl/seccomp_filter.txt)。在大多数发行版中，这个特性在内核中被激活，但是在Red Hat Linux 6这样的发行版中，这个特性被禁用。如果您使用的发行版没有此特性，并且无法升级到启用seccomp的新版本，则必须通过更新$SONARQUBEHOME/conf/sonar.properties_中的sonar.search.javaAdditionalOpts 显式地禁用此安全层：

> sonar.search.javaAdditionalOpts=-Dbootstrap.system_call_filter=false  

可以检查seccomp是否在你的内核上可用：
> $ grep SECCOMP /boot/config-$(uname -r)  

如果你的内核有seccomp，你会看到：
> CONFIG_HAVE_ARCH_SECCOMP_FILTER=y  
> CONFIG_SECCOMP_FILTER=y  
> CONFIG_SECCOMP=y  

有关详细信息，请参阅[Elasticsearch说明文档](https://www.elastic.co/guide/en/elasticsearch/reference/5.6/breaking-changes-5.6.html)。

### 2.2 基准
#### 2.2.1 内容
下列数字是根据大多数中型公司的一般硬件编制的：

App ESXi服务器配置 |  DB ESXi服务器配置
:-|:-
2* Intel(R) Xeon(R) CPU E5-2650 v2 @ 2.60GHz (32 VCPUs)|2* Intel(R) Xeon(R) CPU E5-2650 v2 @ 2.60GHz (32 VCPUs)
128GB RAM| 128GB RAM
1.9 TB volume (RAID5 of 8 Hard Drives of 300GB SAS 15K)|1.9TB volume (RAID5 of 8 hard drives of 300GB SAS 15k)
2*1 GB NICs|2*1 GB NICs
ESXi 6.0| ESXi 6.0

我们创建了两个虚拟机，一个为SonarQube服务器，一个为SonarQube数据库在两个ESXi 6.0服务器：

|应用虚拟机服务配置|数据库虚拟机服务配置|
|:-|:-|
|8 VCPUs|4 VCPUs|
|16GB RAM|8GB RAM|
|20 GB storage for system + 200 GB storage for data (LVM) (RAID5 of 8 hard drives of 300GB SAS 15k)|20 GB storage for system + 200 GB storage for data (LVM)|
|1GB NIC|1GB NIC|
|CentOS 7 64bits |CentOS 7 64bits|
 |   |MySQL 5.6.27 (Oracle Community Edition)|

#### 2.2.2 目标
从SonarQube 5.2+源代码行不再被Elasticsearch索引，因此分析中的代码数量不会影响SearchServer的性能。
通过运行这个基准，我们希望验证托管SonarQube的给定硬件能够支持的数百万个问题。

- SonarQube能消化数百万个问题吗?需要多少时间？
- 我们还能通过SonarQube的前端页面来处理这些上百万的问题吗？

#### 2.2.3 结果
##### 2.2.3.1 指数化的吞吐量
由搜索服务器进行的索引不是线性的：

|问题(百万)  |指数化时间(小时)|
|:-|:-|
|25 | 1|
|60  |2-3|
|100 |6-7|

##### 2.2.3.2 Elasticsearch的内存
根据问题的数量，分配到ElastSearch的RAM是线性的：

|问题(百万) | 搜索服务的内存(GB)|
|:-|:-|
|25 | 4|
|60 | 7|
|100| 12|

ES的内存可以通过`sonar.search.javaOpts`在`$SONARQUBEHOME/conf/sonar.properties_`文件中配置。  
##### 2.2.3.3 CPU配置
使用SonarQube 5.2+， Elasticsearch被配置为使用5个Elasticsearch主切片。这允许SonarQube在默认情况下处理至少4个CPU内核专用于SearchServer的服务器上的5000万个问题。 

|问题(百万)|#切片|#核| |
|:-|:-|:-|:- |
|50 | 5 |  4 |  默认配置|
|30 | 3 |  2 |   |

### 2.3 硬件推荐
#### 2.3.1 数据库
我们建议，对于大型实例，SonarQube使用的数据库驻留在一台机器上，该机器与SonarQube服务器在物理上是分离的，但是在网络上与它很接近。
##### 2.3.1.1 Oracle
如果您的SonarQube服务器运行在Linux上，而您使用的是Oracle，那么Oracle JDBC驱动程序可能由于/dev/randombe而被阻塞。有关此问题的详细信息，请参阅[Oracle文章](http://www.usn-it.de/index.php/2009/02/20/oracle-11g-jdbc-driver-hangs-blocked-by-devrandom-entropy-pool-empty/)。  
为了避免这种情况，您可能需要将此JVM参数添加到SonarQube Web服务器`(sonar.web.javaOpts)`配置中：
> -Djava.security.egd=file:///dev/urandom   

#### 2.3.2 Elasticsearch(又名ES)
ES在后台为SonarQube提供搜索服务。为了确保SonarQube的良好性能，您需要遵循与ES使用相关的建议。

#### 2.3.3 JVM
建议将最小和最大内存设置为相同的值，以防止堆在运行时调整大小，这是一个很耗性能的过程。参见属性`sonar.search.javaOpts`属性的`-Xms`和`-Xmx`。

#### 2.3.4 磁盘
磁盘很容易成为ES的瓶颈。如果你买得起ssd，它们比任何旋转介质都要好得多。支持ssd的节点可以看到查询和索引性能的提高。如果使用旋转介质，请尽可能获得最快的磁盘(高性能服务器磁盘15k RPM驱动器)。  
确保增加机器上打开的文件描述符的数量(或运行SonarQube服务器的用户)。建议将其设置为32k甚至64k。参见ElasticSearch文章。  
对于旋转磁盘和SSD，使用RAID 0是提高磁盘速度的有效方法。由于Elasticsearch副本和数据库主存储，不需要使用RAID的镜像或奇偶校验变体。不要使用远程安装的存储，如NFS、SMB/CIFS或网络附加存储(NAS)。它们通常更慢，显示更大的延迟，平均延迟偏差更大，并且是单点故障。  
**高级部分：**  
如果您正在使用SSD，请确保您的OS I/O调度程序配置正确。当您将数据写入磁盘时，I/O调度程序将决定何时将数据实际发送到磁盘。大多数*nix发行版的默认设置是一个名为cfq(Completely Fair Queuing)的调度程序。这个调度程序为每个进程分配“时间片”，然后优化这些不同队列到磁盘的传递。它针对旋转介质进行了优化:旋转盘片的性质意味着基于物理布局将数据写入磁盘的效率更高。然而，这对于SSD是非常低效的，因为不涉及旋转盘。相反，应该使用deadline或noop。deadline调度程序根据写被挂起的时间进行优化，而noop只是一个简单的FIFO队列。这个简单的改变可以产生巨大的影响。  
如果SQ主目录位于慢速磁盘上，则属性sonar.path。可以使用数据将数据移动到更快的磁盘(例如raid0本地SSD)。

#### 2.3.5 内存
操作系统的机器可用内存必须至少是Elasticsearch堆大小。原因是Lucene(由ES使用)被设计用来利用底层操作系统来缓存内存中的数据结构。这意味着在默认情况下，OS必须至少有1Gb的可用内存。  
不分配超过32 gb。有关更多细节，请参阅[ElasticSearch文章](https://www.elastic.co/cn/)。  
**高级部分：**  
Elasticsearch默认使用混合的mmapfs/niofs目录来存储索引。默认操作系统对mmap计数的限制可能太低，这可能导致内存异常。在Linux上，您可以通过作为根用户运行以下命令来增加限制:
> sysctl -w vm.max_map_count=262144

若要永久设置此值，请在`/etc/sysctl.conf`中设置`vm.max_map_count`。

#### 2.3.6 CPU
如果您需要在更快的cpu和更多的内核之间进行选择，那么选择更多的内核。多核提供的额外并发性将远远超过稍快的时钟速度。  
由于数据本质上分布在多个节点上，所以执行时间取决于最慢的节点。最好有多个媒体盒，而不是一个快一点一个慢一点。

## 3 安装和更新
### 3.1 概述
- 两分钟入门  
要快速尝试SonarQube平台，请遵循两分钟入门指南。
- 安装一个生产实例  
要安装生产实例，请阅读需求，然后遵循安装指南。
- 安装之后  
在服务器启动并运行之后，您需要在将要执行分析的机器上安装一个或多个sonarscanner。
- 升级生产实例  
要升级生产实例，请阅读升级指南和相关的、特定于版本的升级说明。  

### 3.2 两分钟入门指南
#### 3.2.1 通过ZIP文件安装
- 下载[SonarQube社区版](https://www.sonarqube.org/downloads/)
- 解压缩，到如C:\sonarqube或/opt/sonarqube
- 启动SonarQube服务
> \# 在window机器上，执行以下命令：  
> C:\sonarqube\bin\windows-x86-xx\StartSonar.bat  
> \# 在其他操作系统,，使用非管理员用户执行以下命令：  
> /opt/sonarqube/bin/[OS]/sonar.sh console
- 使用系统管理员凭证(admin/admin)登录到http://localhost:9000，并按照内置教程分析您的第一个项目。

**注**：这个演示实例适合用于演示目的，当您准备进入生产环境时，请花一些时间阅读[安装服务器](https://docs.sonarqube.org/7.7/setup/install-server/)(3.3.1)文档。

#### 3.2.2 使用Docker安装
Docker Hub上提供了社区版的Docker镜像，请参阅其中的用法和配置示例。  
**注**：此实例仅适用于演示或测试目的。

### 3.3 安装服务器
#### 3.3.1 安装数据库
支持多个数据库引擎(2.1)。请确保遵循为您的数据库列出的需求，它们是真实的需求，而不是建议。  
创建一个空数据库和一个sonarqube用户，授予sonarqube用户创建、更新和删除此数据库对象的权限。  
##### 3.3.1.1 Microsoft SQL Server
**注**：排序必须区分大小写(CS)和区分重音(AS)。  
**注**：READ_COMMITED_SNAPSHOT必须在SonarQube数据库设置。  
MS SQL数据库的共享锁策略可能会影响SonarQube运行。确保is_read_committed_snapshot_on被设置为true，以防止SonarQube在重载下面临潜在的死锁。  
检查is_read_committed_snapshot_on的查询示例：  
> SELECT is_read_committed_snapshot_on FROM sys.databases WHERE name='YourSonarQubeDatabase';  

更新is_read_committed_snapshot_on的查询示例：  
> ALTER DATABASE YourSonarQubeDatabase SET READ_COMMITTED_SNAPSHOT ON WITH ROLLBACK IMMEDIATE;

如果您想使用集成安全性，您必须从[此连接](https://www.microsoft.com/en-us/download/details.aspx?id=55539)下载Microsoft SQL JDBC Driver 6.2 的包，并将sqljdbc_auth.dlll拷贝到路径中的任何文件夹。您应该使用64位版本的dll来匹配服务器机器的架构。如果您正在将SonarQube作为windows服务运行，并且希望使用集成安全性，请确保运行该服务的windows帐户具有连接SQL服务器的权限。帐户应该具有db_owner数据库角色成员资格。否则，如果您从命令提示符运行SonarQube服务器，并且希望使用集成安全性，那么运行命令提示符的用户应该具有db_owner数据库角色成员资格。还要确保sonar.jdbc。用户名或sonar.jdbc。密码属性被注释掉，否则SonarQube将使用SQL身份验证。
> sonar.jdbc.url=jdbc:sqlserver://localhost;databaseName=sonar;integratedSecurity=true

如果希望使用SQL身份验证，请使用以下连接字符串。还要确保sonar.jdbc。用户名和sonar.jdbc。密码设置正确。
> sonar.jdbc.url=jdbc:sqlserver://localhost;databaseName=sonar
> sonar.jdbc.username=sonarqube
> sonar.jdbc.password=mypassword

##### 3.3.1.2 Oracle
如果同一个Oracle实例上有两个SonarQube schemas，特别是针对两个不同版本的schemas，SonarQube会感到困惑，并选择它找到的第一个schema。为了避免这个问题：
- 应该减少与SonarQube Oracle用户关联的任何特权  
- 或者在Oracle端定义一个触发器，在建立新连接时自动更改SonarQube Oracle用户会话  
Oracle JDBC驱动程序版本12.1.0.1和12.1.0.2有较大的bug，不建议与SonarQube一起使用(请参阅更多细节)。

##### 3.3.1.3 PostgreSQL
如果你想使用自定义模式而不是默认的“公共”模式，必须设置PostgreSQL search_path属性：
> ALTER USER mySonarUser SET search_path to mySonarQubeSchema

##### 3.3.1.4 MySQL（不推荐）
Data Center Edition 不再支持MySQL数据库。  
MySQL中有两个众所周知的引擎:MyISAM和InnoDB。MyISAM是两个引擎中最老的一个，并且正逐步被InnoDB所取代。随着质量控制项目数量的增加，InnoDB的速度明显加快，而SonarQube的扩展性也更好。如果您是SonarQube的早期采用者，那么您可能有一系列仍在使用MyISAM的表。为了提高性能，应该将所有表的引擎更改为InnoDB。  
一旦所有SonarQube表都使用InnoDB引擎，首先要做的就是使用`innodb_buffer_pool_size`参数为MySQL实例分配最大RAM，并为`query_cache_size`参数分配至少15Mb内存。阅读这篇关于InnoDB性能优化基础的文章以获得更多信息。

#### 3.3.2 安装Web服务器
首先，检查需求。然后下载并解压缩该发行版(不要解压缩到以数字开头的目录中)。  
SonarQube不能在基于unix的系统上作为根用户运行，因此需要创建一个专用的用户帐户来使用SonarQube。  
`$SONARQUBE-HOME`(下面)是指向SonarQube发行版已解压缩的目录的路径。
##### 3.3.2.1 设置访问数据库的权限
编辑`$SONARQUBE-HOME/conf/sonar.properties`来配置连接数据库的设置。每个受支持的数据库都可以使用模板。只需取消注释并配置您需要的模板，并注释掉专门用于H2的行:
> \# PostgreSQL示例
> sonar.jdbc.username=sonarqube
> sonar.jdbc.password=mypassword
> sonar.jdbc.url=jdbc:postgresql://localhost/sonarqube

##### 3.3.2.2 添加JDBC驱动包
已经提供了支持的数据库(Oracle除外)的驱动程序，不要更换所提供的驱动程序;它们是唯一受支持的。  
对于Oracle，将JDBC驱动程序复制到`$SONARQUBE-HOME/extensions/jdbc-driver/oracle`中。

##### 3.3.2.3 配置Elasticsearch存储路径
默认情况下，Elasticsearch数据存储在`$SONARQUBE-HOME/data`中，但不建议用于生产实例。相反，您应该将这些数据存储在其他地方，理想情况下存储在具有快速I/O的专用卷中。除了保持可接受的性能外，这样做还将简化SonarQube的升级。  
通过编辑`$SONARQUBE-HOME/conf/sonar.properties`文件去做以下设置：
> sonar.path.data=/var/sonarqube/data  
> sonar.path.temp=/var/sonarqube/temp  

用于启动SonarQube的用户必须具有对这些目录的读写访问权。

##### 3.3.2.4 启动Web服务
默认端口是`9000`，上下文路径是`/`。这些值可以在`$SONARQUBE-HOME/conf/sonar.properties`中更改。
> sonar.web.host=192.0.0.1  
> sonar.web.port=80  
> sonar.web.context=/sonarqube  

执行以下脚本启动服务器:
> \#在Linux/Mac OS：bin//sonar.sh start  
> \#在Windows：bin/windows-x86-XX/StartSonar.bat  

现在，您可以通过`http://localhost:9000`浏览SonarQube(默认的系统管理员凭证是`admin/admin`)。

##### 3.3.2.5 优化Web服务
默认情况下，SonarQube被配置为在任何使用简单Java JRE的计算机上运行。  
为了获得更好的性能，在安装生产实例时要做的首先是使用Java JDK，并通过取消在1`SONARQUBE-HOME/conf/sonar.properties`配置文件中的以下注释来激活服务模式：
> sonar.web.javaOpts=-server  

要更改SonarQube使用的Java JVM，只需编辑`$SONARQUBE-HOME/conf/wrapper.conf`并更新以下行：
> wrapper.java.command=/path/to/my/jdk/bin/java  

##### 3.3.2.6 高级安装功能
- 在Windows或Linux上作为服务运行SonarQube  
- 在代理之后运行SonarQube  
- 使用Docker运行SonarQube社区版  

#### 3.3.3 安装服务器之后
一旦您的服务器安装并运行，您可能还想要安装插件，然后就可以开始分析源代码了。

#### 3.3.4 维修/常见问题
##### 3.3.4.1 为web服务器/计算引擎/elasticsearch分配更多内存
要为服务器端进程分配更多内存，请在`$SONARQUBE_HOME/conf/sonar.properties`中取消注释并编辑相关`javaOpts`属性，特别是：
> sonar.web.javaOpts (minimum values: -server -Xmx768m)  
> sonar.ce.javaOpts  
> sonar.search.javaOpts  

##### 3.3.4.2 不能连接MySQL数据库
默认情况下，出于安全原因，将禁用对MySQL数据库服务器的远程访问。如果希望远程访问数据库服务器，需要遵循以下快速指南。
##### 3.3.4.3 在Windows Vista 启动失败
当安装在Windows Vista的Program Files目录下时，SonarQube似乎无法启动。因此，它不应该安装在那里。
##### 3.3.4.4 由于糟糕的用户表结构，无法在Oracle中启动SonarQube
当Oracle DB中存在其他用户表时，如果sonarqube用户对这个其他用户表具有读访问权限，则sonarqube web服务器无法启动，并抛出如下异常：
> ActiveRecord::ActiveRecordError: ORA-00904: "TOTO": invalid identifier
> : INSERT INTO users (login, name, email, crypted_password, salt, 
> created_at, updated_at, remember_token, remember_token_expires_at, toto, id)
> VALUES('admin', 'Administrator', '', 'bba4c8a0f808f9798cf8b1c153a4bb4f9178cf59', '2519754f77ea67e5d7211cd1414698f465aacebb',
TIMESTAMP'2011-06-24 22:09:14', TIMESTAMP'2011-06-24 22:09:14', null, null, null, ?)  
> ActiveRecord::ActiveRecordError: ORA-00904: "TOTO": invalid identifier
> : INSERT INTO users (login, name, email, crypted_password, salt, 
> created_at, updated_at, remember_token, remember_token_expires_at, toto, id)
> VALUES('admin', 'Administrator', '', 'bba4c8a0f808f9798cf8b1c153a4bb4f9178cf59', 
'2519754f77ea67e5d7211cd1414698f465aacebb', TIMESTAMP'2011-06-24 22:09:14', TIMESTAMP'2011-06-24 22:09:14', null, null, null, ?)

要解决这个问题，必须减少sonarqube Oracle用户的权限，以删除对其他用户表的读访问。

##### 3.3.4.5 无法通过代理连接到应用市场
仔细检查`$SONARQUBE_HOME/conf/sonar.properties`中是否正确设置了代理的设置。注意，如果您的代理用户名包含“”(反斜杠)，那么它应该转义-例如，用户名`domain\user`在文件中应该是这样的：
> http.proxyUser=domain\\\user  

对于某些代理，异常`“java.net.ProtocolException: Server redirected too many times”`可能意味着配置了错误的用户名或密码。
##### 3.3.4.6 异常 java.lang.RuntimeException: can not run elasticsearch as root
SonarQube启动一个Elasticsearch进程，运行SonarQube本身的帐户将用于Elasticsearch进程。由于Elasticsearch不能用root用户运行，这意味着SonarQube也不能用root用户运行。您必须选择一些其他的非root帐户来运行SonarQube，最好是专门用于此目的的帐户。

### 3.4 配置和操作服务器
#### 3.4.1 将SonarQube作为windows的一个服务去运行
安装/卸载NT服务(可能必须以管理员身份运行这些文件)：
> %SONARQUBE_HOME%/bin/windows-x86-64/InstallNTService.bat  
> %SONARQUBE_HOME%/bin/windows-x86-64/UninstallNTService.bat  

启动/停止服务
> %SONARQUBE_HOME%/bin/windows-x86-64/StartNTService.bat  
> %SONARQUBE_HOME%/bin/windows-x86-64/StopNTService.bat  

#### 3.4.2 使用SystemD在Linux上作为服务运行SonarQube
在使用SystemD的Unix系统上，可以将SonarQube作为服务安装。你不能运行SonarQube作为根在'nix系统。理想情况下，您将创建一个专门用于运行SonarQube的新帐户。我们假设：
- 用于启动服务的用户是sonarqube
- 用于启动服务的组是sonarqube
- Java虚拟机安装在/opt/java /中
- SonarQube已解压缩到/opt/sonarqube /中
然后创建文件/etc/systemd/system/sonarqube.service服务基于以下内容：
> [Unit]  
> Description=SonarQube service  
> After=syslog.target network.target
> 
> [Service]  
> Type=simple  
> User=sonarqube  
> Group=sonarqube  
> PermissionsStartOnly=true  
> ExecStart=/bin/nohup /opt/java/bin/java -Xms32m -Xmx32m -Djava.net.preferIPv4Stack=true -jar /opt/sonarqube/lib/sonar-application-7.4.jar  
> StandardOutput=syslog  
> LimitNOFILE=65536  
> LimitNPROC=8192  
> TimeoutStartSec=5  
> Restart=always  
> 
> [Install]  
> WantedBy=multi-user.target  

**注意**：  

- 由于sonar-application jar包名称以SonarQube版本号结尾，因此您需要在安装和每次升级时相应地调整ExecStart命令。
- SonarQube数据目录`/opt/sonarqube/data`和扩展目录`/opt/sonarqube/extensions`应该属于sonarqube用户。作为一个好的惯例，其余部分应该由root拥有。

一旦你sonarqube。创建并正确配置服务文件后，运行：
> sudo systemctl enable sonarqube.service  
> sudo systemctl start sonarqube.service  

#### 3.4.3 SonarQube服务随Linux启动而启动
下面的代码已经在Ubuntu 8.10和CentOS 6.2上测试过了。
创建`/etc/init.d/sonar`文件，为以下内容：
> \#!/bin/sh  
> \#  
> \# rc file for SonarQube  
> \#  
> \# chkconfig: 345 96 10  
> \# description: SonarQube system (www.sonarsource.org)  
> \#  
> \### BEGIN INIT INFO  
> \# Provides: sonar  
> \# Required-Start: $network  
> \# Required-Stop: $network  
> \# Default-Start: 3 4 5  
> \# Default-Stop: 0 1 2 6  
> \# Short-Description: SonarQube system (www.sonarsource.org)  
> \# Description: SonarQube system (www.sonarsource.org)  
> \### END INIT INFO  
>   
> /usr/bin/sonar $*  

启动时注册SonarQube (RedHat, CentOS, 64位)：

> sudo ln -s $SONAR_HOME/bin/linux-x86-64/sonar.sh /usr/bin/sonar  
> sudo chmod 755 /etc/init.d/sonar  
> sudo chkconfig --add sonar  

#### 3.4.5 代理后的服务安全性
如果希望在代理之后运行SonarQube服务器，本节将帮助您配置它。这可以用于安全考虑或合并多个不同的应用程序。
##### 3.4.5.1 服务器配置
要在HTTPS上运行SonarQube服务器，必须构建一个标准的反向代理基础设施。  
必须将反向代理配置为在每个HTTP请求头中设置值`X_FORWARDED_PROTO: https`。如果没有此属性，SonarQube服务器发起的重定向将依赖于HTTP。

##### 3.4.5.2 使用Apache代理
我们假设您已经安装了带有modproxy模块的Apache 2,SonarQube正在运行，并且可以在“http://privatesonarhost:sonarport/”上使用，并且您希望为www.public_sonar.com配置一个虚拟地址。  
此时，编辑www.public_sonar.com虚拟地址主机的HTTPd配置文件。通过mod_proxy在http://www.public_sonar.com/上公开SonarQube包括以下内容：
> ProxyRequests Off  
> ProxyPreserveHost On  
> <VirtualHost *:80>  
>   ServerName www.public_sonar.com  
>   ServerAdmin admin@somecompany.com  
>   ProxyPass / http://private_sonar_host:sonar_port/  
>   ProxyPassReverse / http://www.public_sonar.com/  
>   ErrorLog logs/somecompany/sonar/error.log  
>   CustomLog logs/somecompany/sonar/access.log common  
> </VirtualHost>  

Apache配置将根据您自己的应用程序的需求和您打算将SonarQube对外网开放的方式而变化。如果您需要更多关于Apache HTTPd和mod_proxy的详细信息，请参阅http://httpd.apache.org。

##### 3.4.5.3 使用Nginx
我们假设您已经安装了Nginx，正在为www.somecompany.com使用虚拟主机，SonarQube正在运行，并且可以在http://sonarhost:sonarport/上访问。  
此时，编辑Nginx配置文件，在http://www.somecompany.com/上公开SonarQube包括以下内容：
> \# the server directive is nginx's virtual host directive  
> server {  
>   \# port to listen on. Can also be set to an IP:PORT  
>   listen 80;  
>    
>   \# sets the domain[s] that this vhost server requests for  
>   server_name www.somecompany.com;  
>    
>   location / {  
>     proxy_pass http://sonarhost:sonarport;  
>   }  
> }  

Nginx配置将根据您自己的应用程序的需求和您打算将SonarQube公开给外部世界的方式而变化。如果您需要更多关于Nginx的详细信息，请参见https://www.nginx.com/resources/admin-guide/reverse-proxy/。  
注意，您可能需要增加最大URL长度，因为SonarQube请求的URL可以超过2048。

##### 3.4.5.4 使用IIS
请参阅:http://blog.jessehouwing.nl/2016/02/configure-ssl-for-sonarqube-on-windows.html
注意，本文中描述的设置不适用于通过IIS进行SAML。

### 3.5 安装一个插件
可以通过两种方式为SonarQube安装插件：

- 在SonarQube前端页面通过应用市场自动安装插件  
- 手工安装-如果您的SonarQube实例无法访问Internet，您将使用此方法。  

#### 3.5.1 应用市场安装
如果您能够访问Internet，并且您与具有全局权限“管理系统”的SonarQube用户登录系统，则可以访问Administration >Marketplace。

- 找到要安装的插件
- 点击安装，等待下载处理

下载完成后，将使用“Restart”按钮重新启动实例。有关如何配置SonarQube服务器以连接到Internet的详细信息，请参阅Marketplace。  
#### 3.5.2 手动安装
在您想要安装的插件专用页面(例如:for Python: SonarPython)，单击与SonarQube版本兼容的版本的“Download”链接。  
将下载的jar放到`$SONARQUBE_HOME/extensions/plugins`中，删除相同插件的任何以前版本。一旦完成，您将需要重新启动SonarQube服务器。

##### 3.5.2.1 许可证
如果安装了商业版，则需要在Administration > Configuration >License Manager中设置许可证密钥，然后才能使用它。

### 3.6 将服务器安装为集群
只有在数据中心版本中，才能将SonarQube作为集群运行。数据中心版本允许SonarQube在集群配置中运行，使其对故障具有弹性。
#### 3.6.1 要求
##### 3.6.1.1 应用服务
您需要五个专用于SonarQube的服务器。服务器可以是vm，不需要物理机器。
服务器必须位于同一位置(不支持地理冗余)。  
您可以在2.1节页面中找到服务器的操作系统需求。
##### 3.6.1.2 数据库服务
数据中心版本支持PostgreSQL、Oracle和Microsoft SQL Server。如果您的数据当前存储在MySQL中，您可以使用SonarQube DB复制工具来移动它。
##### 3.6.1.3 负载均衡器
除了五个SonarQube服务器之外，您还必须配置一个反向代理/负载均衡器来平衡两个应用程序节点之间的负载流量。反向代理/负载均衡器的精确配置会因供应商而异，但是SonarQube数据中心版本的要求非常简单：

- 在SonarQube集群中配置的两个应用程序节点之间共享请求(负载)
- 如果您正在使用HTTPS，请确保满足在代理背后保护SonarQube的要求
- 注意：没有要求负载均衡器保存会话;这由内置的JWT机制处理

##### 3.6.1.4 许可证
您需要一个专用的许可证来激活DC版本。如果您还没有，请联系SonarSource销售团队。
##### 3.6.1.5 支持
不要独自开始这段旅程;作为数据中心版本的客户SonarSource将帮助您设置和配置集群。联系SonarSource支持部门寻求帮助。

#### 3.6.2 集群拓扑结构
有两种类型节点：

- 负责处理来自用户的web请求的应用程序节点(WebServer流程)和处理分析报告(ComputeEngine流程) 
- 一个搜索节点，它是一个存储数据索引的弹性Elasticsearch过程（不会翻译）
为了达到高可用性，数据中心版本唯一支持的配置包括5台服务器：
- 包含WebServer和ComputeEngine的两个应用程序节点
- 宿主Elasticsearch的3个搜索节点。由于性能原因，对于这些节点，SSD明显优于HDD
使用此配置，可以在不影响服务的情况下丢失节点。更准确地说，一个应用程序节点和一个搜索节点可以在不影响用户的情况下丢失。

下面是支持的拓扑的模式：
 
##### 3.6.2.1 机器
下面是我们使用200万个问题数据库执行验证时使用的机器类型。这可以作为构建集群的最低建议。
（1）搜索节点由Amazon EC2 m4.2xlarge组成:8个vcpu, 32GB RAM - 16GB分配给Elasticsearch
（2）应用节点由Amazon EC2 m4构成。xlarge: 4个vcpu, 16GB RAM
#### 3.6.3 安装细节
准备您的个性化SonarQube包：
（1）按照通常安装服务器文档的步骤安装SonarQube数据中心版本
（2）安装您可能需要的所有其他插件，确认与数据库的连接工作正常。如果您手动执行此步骤，请确保使用插件版本矩阵检查与SonarQube版本的兼容性
（3）压缩目录$SONARQUBE_HOME
（4）现在您有了自己的个性化SonarQube数据中心版本包
在其他4个节点上部署SonarQube包：
预期所有应用程序节点在硬件和软件方面都是相同的(相同的JVM构建)。类似地，所有搜索节点应该彼此相同。但是应用程序和搜索节点可能不同。通常，搜索节点配置的CPU和RAM比应用程序节点多。
（1）从前面步骤的其他4个节点上解压缩您的个性化SonarQube包
（2）祝贺您，现在您有了两个应用程序节点和三个搜索节点，它们在SonarQube软件方面完全相同

#### 3.6.4 配置
现在，您已经有5台机器使用相同的SonarQube软件，是时候开始配置它们来专用化它们了。有些将成为应用程序节点，有些将成为搜索节点。
其思想如下:您需要编辑每个节点上的sonar.properities文件，以配置节点的专门化。在下面的例子中，我们假设：

- 具有IP地址ip1和ip2的vm (server1、server2)将是应用程序节点
- 具有IP地址ip3、ip4和ip5 (server3、server4和server5)的vm将是搜索节点

每个节点的默认配置如下：
Server1
sonar.cluster.enabled=true
sonar.cluster.hosts=ip1,ip2,ip3,ip4,ip5
sonar.cluster.search.hosts=ip3,ip4,ip5
sonar.cluster.node.type=application
sonar.auth.jwtBase64Hs256Secret=Vf4TRrfS6tvsFIHsQlgfhDUkiw3r8=
Server2
sonar.cluster.enabled=true
sonar.cluster.hosts=ip1,ip2,ip3,ip4,ip5
sonar.cluster.search.hosts=ip3,ip4,ip5
sonar.cluster.node.type=application
sonar.auth.jwtBase64Hs256Secret=Vf4TRrfS6tvsFIHsQlgfhDUkiw3r8=
Server3
sonar.cluster.enabled=true
sonar.cluster.hosts=ip1,ip2,ip3,ip4,ip5
sonar.cluster.search.hosts=ip3,ip4,ip5
sonar.cluster.node.type=search
sonar.search.host=ip3
Server4
sonar.cluster.enabled=true
sonar.cluster.hosts=ip1,ip2,ip3,ip4,ip5
sonar.cluster.search.hosts=ip3,ip4,ip5
sonar.cluster.node.type=search
sonar.search.host=ip4
Server5
sonar.cluster.enabled=true
sonar.cluster.hosts=ip1,ip2,ip3,ip4,ip5
sonar.cluster.search.hosts=ip3,ip4,ip5
sonar.cluster.node.type=search
sonar.search.host=ip5
这里列出了完整的集群参数集。
完成此配置之后，休息一下，喝杯咖啡，然后就可以操作集群了。

### 3.7 配置和操作集群（待补充）

### 3.8 更新SonarQube服务
跨多个非LTS版本的升级将自动处理。但是，如果在迁移路径中有一个LTS版本，则必须首先迁移到这个LTS，然后再迁移到目标版本。
例1:5.1 -> 7.0，迁移路径为5.1 -> 5.6.7 LTS -> 6.7。x LTS -> 7.0
例2:6.2 -> 6.7，迁移路径为6.2 -> 6.7。x LTS(其中x是6.7版本的最新补丁——您不需要安装所有中间补丁，只需使用最新的补丁)

#### 3.8.1 升级方法
这是一个通用的升级指南，请仔细阅读您的目标版本和每个中间版本(如果有的话)的升级说明。
计划升级到商业版？如果您打算迁移到6.7 LTS并安装一个商业版本，请阅读这篇文章。
在开始之前，备份SonarQube数据库。升级一般不会出现什么问题，但是为了防止发生意外情况，请您提前备份。
（1）下载并解压您版本的SonarQube发行版到一个新的目录中，例如$NEW_SONARQUBE_HOME
（2）手动安装与SonarQube版本兼容的非默认插件。使用兼容性矩阵确保您安装的版本与服务器版本兼容。注意，您的版本中所有SonarSource源代码分析器的最新版本都是默认安装的。不建议简单地将插件从旧服务器复制到新服务器;不兼容或重复的插件可能会导致启动错误。
（3）更新sonar.properities和wrapper.conf文件内容($NEW_SONARQUBE_HOME/conf)，根据$OLD_SONARQUBE_HOME/conf目录(web服务器URL、数据库、ldap设置等)中相关文件的设置。不要复制粘贴旧文件。如果您正在使用Oracle DB，请将其JDBC驱动程序复制到$NEW_SONARQUBE_HOME/extensions/jdbc-driver/oracle中。
（4）停掉老的SonarQube服务
（5）启动新的SonarQube服务
（6）浏览器访问http://yourSonarQubeServerURL/setup并遵循安装说明
（7）重新分析项目以获得新的数据

#### 3.8.2 其他需要关注的
##### 3.8.2.1 清理Oracle
从6.6开始，如果您正在使用Oracle，您可能需要执行另外一个步骤。在Oracle上，要删除的数据库列现在被标记为未使用，并且不再物理删除。要回收磁盘空间，Oracle管理员必须手动删除这些未使用的列。SQL请求是ALTER TABLE foo DROP未使用的列。相关的表列在系统表all_unused_col_tabs中。

##### 3.8.2.2 额外的数据库维护
一旦技术升级完成(就在最后一步之前)，建议刷新数据库的统计数据并重新构建数据库的索引。
对于PostgreSQL，这意味着执行VACUUM FULL。根据PostgreSQL文档：
在正常的PostgreSQL操作中，被更新删除或废弃的元组不会从表中物理删除;它们一直存在，直到VACUUM完成。
##### 3.8.2.3 扫描仪更新
升级SonarQube时，还应该确保使用最新版本的SonarQube扫描仪，以利用扫描仪端的特性和修复程序。请检查您使用的扫描仪的文档页面，以获得与SonarQube和您的构建工具兼容的最新版本。

##### 3.8.2.4 SonarQube作为一个Linux或Windows服务
如果使用外部配置(如脚本或Windows服务)来控制服务器，则需要将其更新为指向$NEW_SONARQUBE_HOME。
如果您使用InstallNTService.bat将SonarQube安装为Windows服务，请在运行$NEWSONARQUBEHOME的InstallNTService.bat之前运行$OLDSONARQUBEHOME/bin/…/UninstallNTService.bat。

#### 3.8.3 版本升级说明
通常SonarQube发行版会提供一些特定的建议，用于从以前的版本升级。您应该阅读当前版本和目标版本之间的每个版本的升级说明。要从版本升级说明中未列出的版本进行升级，请参阅以前版本的文档。

### 3.9 版本升级说明

### 3.10 常见问题

## 4 源码分析
### 4.1 概述
一旦安装了SonarQube平台，就可以安装分析器并开始创建项目了。为此，您必须安装和配置最适合您需要的扫描仪。你是用：
（1）Gradle - SonarScanner for Gradle
（2）MSBuild - SonarScanner for MSBuild
（3）Maven - use the SonarScanner for Maven
（4）Jenkins - SonarScanner for Jenkins
（5）Azure DevOps - SonarQube Extension for Azure DevOps
（6）Ant - SonarScanner for Ant
（7）anything else (CLI) - SonarScanner
注意：我们不建议在运行SonarQube分析的机器上运行杀毒扫描器，这可能导致不可预测的行为。
项目在第一次分析时自动在平台中创建。但是，如果您需要在项目进行第一次分析之前对其进行一些配置，您可以选择通过管理选项提供配置。

#### 4.1.1 分析产生了什么
SonarQube可以对20多种语言进行分析。这个分析的结果将是质量度量和问题(编码规则被破坏的实例)。然而，分析的内容会因语言的不同而有所不同：
（1）在所有语言中，“blame”数据将自动从受支持的SCM提供者导入。自动支持Git和SVN。其他提供程序需要额外的插件。
（2）在所有语言上，都要执行源代码的静态分析(Java文件、COBOL程序等)。
（3）可以对某些语言(Java中的.class文件、c#中的.dll文件等)执行编译代码的静态分析。
（4）可以对某些语言执行代码的动态分析。

#### 4.1.2 所有文件都会被分析
默认情况下，只有被语言分析器识别的文件才会在分析期间加载到项目中。例如，如果您的SonarQube实例上只有SonarJava SonarJS，那么将加载所有.java和.js文件，但是.xml文件将被忽略。
#### 4.1.3 分支和拉请求
Developer Edition增加了分析项目的发布/长生命周期分支、特性/短生命周期分支和拉请求的能力，以及在一些SCM接口中自动装饰拉请求的能力。有关分支的更多信息，请参见分支概述。
#### 4.1.4 分析过程中发生了什么
在分析过程中，从服务器请求数据，分析提供给分析的文件，最后以报告的形式将结果数据发送回服务器，然后在服务器端异步地分析数据。
分析报告被排队，并按顺序处理，所以很可能在分析日志显示完成后的短时间内，更新后的值在SonarQube项目中不可见。但是，您将能够知道发生了什么，因为一个图标将被添加到项目名称右侧的项目主页上。鼠标移到它上面以获得更多的细节(如果您使用适当的权限登录，则会看到链接)。
 
处理完成后图标消失，但如果分析报告处理由于某种原因失败，图标会发生变化:
 

#### 4.1.5 常见问题
问：分析报java.lang.OutOfMemoryError: GC overhead limit exceeded错误，我该怎么办？
答：这意味着您的项目太大或太复杂，扫描仪无法使用默认内存分配进行分析。要解决这个问题，您需要为运行分析的进程分配一个更大的堆(使用-Xmx[此处的数值])。一些CI引擎可能会为您提供一个输入来指定必要的值，例如，如果您在Jenkins作业中使用Maven构建步骤来运行分析。否则，使用Java选项设置更高的值。注意，这里省略了设置Java选项的细节，因为它们随环境而异。

### 4.2 分析参数
可以在多个位置设置配置项目分析的参数。参数层次如下：
（1）在UI中定义的全局分析参数适用于所有项目(从顶部栏转到Administration > Configuration > General Settings（管理>配置>一般设置）)
（2）在UI中定义的项目分析参数覆盖全局参数(在项目级别，转到Administration > General Settings（管理>通用设置）)
（3）在项目分析配置文件或分析器配置文件中定义的项目分析参数可以覆盖在UI中定义的参数
（4）启动分析时定义的分析/命令行参数覆盖项目分析参数
注意：只有通过UI设置的参数才存储在数据库中。例如，如果你覆盖 sonar.exclusions 通过命令行为特定项目排除参数，它不会存储在数据库中。例如，SonarLint中带有连接模式的分析仍然会使用UI中定义的排除项执行，因此存储在DB中。
还请注意，下面的参数列表并不完整。在接口中显示的大多数属性键，在全局和项目级别上，也可以设置为分析参数。然而，排除/包含在UI中更容易管理。
有关测试覆盖率和执行的特定于语言的参数，请参见测试覆盖率和执行。有关与外部问题报告相关的特定于语言的参数，请参见[外部问题](/analysis/external-issues)。

#### 4.2.1 必选参数
##### 4.2.1.1 服务参数

|键 |  描述 | 默认值|
|:-|:-|:-|
|sonar.host.url | SonarQube服务的访问地址  |  http://localhost:9000 |

##### 4.2.1.2 项目配置
键   描述  默认值
sonar.projectKey    项目的唯一标识。允许的字符是:字母、数字、-、_、.和:，至少有一个非数字。  对于Maven项目，默认值为<groupId>:<artifactId>

#### 4.2.2 可选参数
##### 4.2.2.1 项目身份属性
键   描述  默认值
sonar.projectName   将显示在web界面上的项目的名称。   Maven项目的<name>，否则为项目键。如果没有提供，并且数据库中已经有一个名称，则不会覆盖它
sonar.projectVersion    项目版本    Maven项目的<version>，否则为“未提供”
##### 4.2.2.2 用户身份验证
如果“任何人”虚拟用户组没有执行分析的权限，则需要提供具有执行分析权限的用户的凭据，以便分析在此之下运行。
键   描述  默认值
sonar.login 具有对项目执行分析权限的SonarQube用户的登录或身份验证令牌。  
sonar.password  sonar.login的name对应的密码，如果使用身份验证令牌，则应将此保留为空。  
##### 4.2.2.3 网络服务
键   描述  默认值
sonar.ws.timeout    等待Web服务调用响应的最长时间(以秒为单位)。只有当您在等待服务器响应Web服务调用的分析过程中遇到超时时，从缺省值修改此值才有用。 60
##### 4.2.2.4 项目配置
键   描述  默认值
sonar.projectDescription    项目描述    Maven项目的<description>标签
sonar.links.homepage    项目主页    Maven项目的<url>标签
sonar.links.ci  持续集成    Maven项目的<ciManagement><url>标签
sonar.links.issue   问题追踪器   Maven项目的<issueManagement><url>标签
sonar.links.scm 项目源码库   Maven项目的<scm><url>
sonar.sources   包含主源文件的目录的逗号分隔路径。   从Maven、Gradle、MSBuild项目的构建系统中读取。当未配置sonar.sources或者sonar.tests时，默认为project base目录
sonar.tests 包含测试源文件的目录的逗号分隔路径。  从Maven、Gradle、MSBuild项目的构建系统中读取。否则默认为空。
sonar.sourceEncoding    源文件的编码。例如:UTF-8, MacRoman, Shift_JIS。此属性可由Maven项目中的标准属性project.build.sourceEncoding替换，可用编码的列表取决于您的JVM。  系统编码
sonar.externalIssuesReportPaths 以逗号分隔的一般问题报告路径列表。   
sonar.projectDate   为分析分配一个日期。此参数仅在需要追溯创建未分析项目的历史时才有用。格式是yyyy-MM-dd，例如:2010-12-01。由于您不能执行数据库中最近一次分析之前的分析，所以您必须按照时间顺序重新创建您的项目历史，最老的优先。注意:如果您希望创建长时间运行的历史记录，可能需要调整 housekeeping设置。    当前时间
sonar.projectBaseDir    当需要在启动目录之外的目录中进行分析时，请使用此属性。例如，分析从jenkins/jobs/myjob/workspace开始，但是要分析的文件是ftpdrop/cobol/project1。路径可以是相对的，也可以是绝对的。不是指定源目录，而是指定源目录的父目录。这里指定的值成为新的“分析目录”，然后指定其他路径，就好像分析是从sonar.projectBaseDir的指定值开始的一样。注意，分析过程将需要在此目录下的写权限；将会创建sonar工作目录sonar.working.directory    
sonar.working.directory 设置SonarScanner或SonarScanner for Ant(版本大于2.0)触发的分析的工作目录。此属性与MSBuild的SonarScanner不兼容。路径必须是相对的，并且对于每个项目都是唯一的。注意:在每次分析之前都会删除指定的文件夹。 .sonar
sonar.scm.provider  此属性可用于显式地告诉SonarQube应该使用哪个SCM插件来获取项目上的SCM数据(以防自动检测不起作用)。这个属性的值总是小写的，取决于插件(例如。"tfvc"为tfvc插件)。查看每个插件的文档页面了解更多信息。  
sonar.scm.forceReloadAll    默认情况下，只检索更改文件的错误信息。将此属性设置为true，以加载所有文件的指责信息。如果您觉得一些SCM数据已经过时，但是SonarQube没有从SCM引擎获得最新的信息，那么这一点是非常有用的。    
sonar.scm.exclusions.disabled   对于支持的引擎，SCM忽略的文件，即.gitignore中列出的文件，也会被分析自动忽略。将此属性设置为true以禁用该特性。 
sonar.buildString   使用此属性传递的字符串将与分析一起存储，并在api/ project_analysis /search的结果中可用，从而允许您稍后识别特定的分析并获得其ID，以便与api/project_analyses/set_baseline一起使用。    
sonar.analysis.[yourKey]    这个属性存根允许您将自定义键/值对插入到分析上下文中，分析上下文也将被转发给webhooks。


#### 4.2.3 重复度
键   描述  默认值
sonar.cpd.${language}.minimumtokens 当一行代码中至少出现100个（被sonar.cpd.${language}.minimumTokens重新指定）重复的token，这段代码就被认为是重复的，分布在至少10行（被sonar.cpd.${language}.minimumLines重新指定）代码中。对于Java项目，当一行中至少有10条语句时，不管标记和行数是多少，都会认为代码段是重复的。无法重写此阈值。   100
sonar.cpd.${language}.minimumLines  见以上 10

#### 4.2.4 分析日志
键   描述  默认值
sonar.log.level 控制分析过程中产生的日志数量/级别。
DEBUG：在调试级别显示INFO级别日志更多细节，类似于sonar.verbose = true。
TRACE：显示调试日志+ SonarScanner执行的所有ElasticSearch查询和Web API调用的时间。    INFO
sonar.verbose   向客户机和服务器端分析日志添加更多细节。激活扫描仪的调试模式，并将客户端环境变量和系统属性添加到分析报告处理的服务器端日志中。注意:如果密码等敏感信息存储为服务器端环境变量，则此设置可能会公开这些信息。   false
sonar.showProfiling 显示日志，以查看分析程序花费的时间。当通过SonarScanner并且SonarScanner for Maven使用target/sonar/profiling/分析开始运行时这个参数将在<workingDir>是.sonar/profiling/的<workingDir>/profiling/<moduleKey>-profiler.xml生成一个包含这些时间信息的文件。   false
sonar.scanner.dumpToFile    将传递给扫描器API作为调试分析手段的属性的完整列表输出到指定文件。  
sonar.scanner.metadataFilePath  设置扫描器写入report-task.txt文件的位置，其中包含ceTaskId。   sonar.working.directory的值

#### 4.2.5 已弃用参数
为了完整起见，列出了这些参数，但是不建议在新的分析中使用这些参数。
键   描述  默认值
sonar.branch
从SQ 6.7版本弃用 开发人员版提供了功能齐全的分支功能。管理供应链管理分支。同一项目的两个分支在SonarQube中被认为是不同的项目。因此，在B1分支中的项目a中发现的问题与在B2分支中的项目a中发现的问题没有关联。当问题在B1中解决时，无法自动解决B2中的问题，因为A-B1和A-B2被认为是独立的项目。    INFO
sonar.links.scm_dev
从SQ 7.1版本弃用 开发人员连接。 Maven项目的<scm><developerConnection>

### 4.3 测试覆盖和执行
此页面列出了与测试覆盖率和执行报告相关的分析参数。有关更多其他参数，请参见分析参数。
Sonar源码分析程序不会运行您的测试并生成报告。它们只导入预生成的报告。下面您将找到用于导入覆盖率和执行报告的特定于语言和工具的分析参数。有关生成报告的信息，请参阅分析程序子目录中的特定于语言的信息。
有些属性在路径中支持以下通配符。支持通配符的属性的注释将提到这一事实。如果备注中没有说明支持通配符，则说明不支持。
符号  含义
?   一个字符
*   任意数量字符
**  任意数量的目录

#### 4.3.1 测试覆盖
除非另外指定，否则这些属性关联为项目设置的根值。
语言  属性  附注
所有  sonar.coverage.jacoco.xmlReportPaths    指向JaCoCo XML覆盖报告的路径。
所有  sonar.coverageReportPaths   指向通用测试数据格式的覆盖率报告。
Apex    sonar.apex.coverage.reportPath  指向由Salesforce CLI的apex:test:run命令生成的 test-result-codecoverage.json报告文件。注意，您必须设置Salesforce DX项目并链接到您的组织
C / C++ / Objective-C   sonar.cfamily.gcov.reportsPath  指向包含*.gcov报告（而不是由gcovr生成的XML报告）的本地目录
C / C++ / Objective-C   sonar.cfamily.llvm-cov.reportPath   
C / C++ / Objective-C   sonar.cfamily.vscoveragexml.reportsPath 路径可以是绝对路径，也可以是相对于解决方案目录的路径。支持路径通配符(见上面)。注意，不支持Visual Studio提供的.coveragexml报告格式。
C / C++ / Objective-C   sonar.cfamily.bullseye.reportPath   由于格式不兼容，不支持Bullseye8.9.59到Bullseye8.9.62版本的报告。
C#  sonar.cs.vscoveragexml.reportsPaths 指向Visual Studio代码覆盖率报告。多个路径可以用逗号分隔，也可以通过通配符包含。请参阅下面关于导入.NET报告的说明。
C#  sonar.cs.dotcover.reportsPaths  指向dotCover覆盖报告。请参阅下面关于导入.NET报告的说明。
C#  sonar.cs.opencover.reportsPaths 打开覆盖报告的路径。请参阅下面关于导入.NET报告的说明。
Flex    soanr.flex.cobertura.reportPath 指向Cobertura XML报告的路径。可以是绝对的，也可以是相对于项目基本目录的。
Go  sonar.go.coverage.reportPaths   以逗号分隔的覆盖报告文件路径列表。从SonarGo 1.1开始，就支持路径通配符(见上文)。
Java    sonar.jacoco.reportPaths    指向JaCoCo报告的二进制格式的路径。只支持Java。
JavaScript  sonar.javascript.lcov.reportPaths   以逗号分隔的LCOV覆盖报告文件路径列表。路径可以是绝对的，也可以是相对于项目根的。
PHP sonar.php.coverage.reportPaths  逗号分隔的Clover xml格式覆盖报告文件的路径列表。路径可以是绝对的，也可以是相对于项目根的。
Python  sonar.python.coverage.reportPaths   以逗号分隔的到Cobertura XML格式的覆盖率报告的路径列表。支持路径通配符(参见上面)。保留未设置以使用默认值(cover -reports/*coverage-*.xml)。
Ruby    sonar.ruby.coverage.reportPaths 以逗号分隔的SimpleCov .resultset路径列表。json文件报告。路径可以是绝对的，也可以是相对于项目根的。
Scala   sonar.scala.coverage.reportPaths    由Scoverage生成的scoverage .xml报告文件的路径列表，以逗号分隔。
Swift, Xcode 9.3+       您可以使用sonar-scanning-examples/swift-coverage项目中的xccov-to-sonarqube- Generic .sh脚本将输出从Xcode 9.3的xccov工具转换为通用的测试数据格式。
Swift, Xcode 7-9.2  sonar.swift.coverage.reportPath 指向llvm-cov生成的报告的路径显示。路径可以是绝对的，也可以是相对于项目根目录的。
TypeScript  sonar.typescript.lcov.reportPaths   以逗号分隔的LCOV覆盖报告路径列表。路径可以是绝对的，也可以是相对于项目根的。


#### 4.3.2 执行测试
除非另外指定，否则这些属性会被指定为于项目根的值。
语言  属性  附注
所有  sonar.testExecutionReportPaths  以逗号分隔的到通用执行数据格式的执行报告的路径列表。
C / C++ / Objective-C   sonar.cfamily.cppunit.reportsPath   保存CPPUnit报告的目录的路径。注意，虽然诸如测试数量之类的度量显示在项目级别，但是没有可用的钻取。
C#  sonar.cs.vstest.reportsPaths    到VSTest报告的路径。多个路径可以用逗号分隔，也可以通过通配符包含。注意，虽然诸如测试数量之类的度量显示在项目级别，但是没有可用的钻取。
C#  sonar.cs.nunit.reportsPaths NUnit执行报告的路径。多个路径可以用逗号分隔，也可以通过通配符包含。注意，虽然诸如测试数量之类的度量显示在项目级别，但是没有可用的钻取。
C#  sonar.cs.mstest.reportsPaths    MSTest执行报告的路径。多个路径可以用逗号分隔，也可以通过通配符包含。注意，虽然诸如测试数量之类的度量显示在项目级别，但是没有可用的钻取。
C#  sonar.cs.xunit.reportsPaths xUnit执行报告的路径。多个路径可以用逗号分隔，也可以通过通配符包含。注意，虽然诸如测试数量之类的度量显示在项目级别，但是没有可用的钻取。
Go  sonar.go.tests.reportPaths  以逗号分隔的单元测试报告文件路径列表。路径可以是绝对的，也可以是相对于项目根的。
Java    sonar.junit.reportPaths 逗号分隔的路径列表，以确保生成xml格式的报告。
PHP sonar.php.tests.reportPath  到PHPUnit单元测试执行报告文件的路径。路径可以是绝对的，也可以是相对于项目根目录的。
Python  sonar.python.xunit.reportPath   单元测试执行报告的路径。如未指定则使用默认值(xunit-reports/xunit-result-*.xml)，支持路径通配符(见上面)。如果报告中的任何路径失效，设置sonar.python.xunit.skipDetails=true只收集项目级别的详细信息。
TypeScript      您可以使用jest-sonar-reporter或karma-sonarqube-unit-reporter创建通用执行数据格式的报告。这两个包都可以在npm上使用。
VB.NET  sonar.vbnet.vstest.reportsPaths 到VSTest执行报告的路径。多个路径可以用逗号分隔，也可以通过通配符包含。注意，虽然诸如测试数量之类的度量显示在项目级别，但是没有可用的钻取。
VB.NET  sonar.vbnet.nunit.reportsPaths  NUnit执行报告的路径。多个路径可以用逗号分隔，也可以通过通配符包含。注意，虽然诸如测试数量之类的度量显示在项目级别，但是没有可用的钻取。
VB.NET  sonar.vbnet.mstest.reportsPaths MSTest执行报告的路径。多个路径可以用逗号分隔，也可以通过通配符包含。注意，虽然诸如测试数量之类的度量显示在项目级别，但是没有可用的钻取。
VB.NET  sonar.vbnet.xunit.reportsPaths  xUnit执行报告的路径。多个路径可以用逗号分隔，也可以通过通配符包含。注意，虽然诸如测试数量之类的度量显示在项目级别，但是没有可用的钻取。

关于导入.NET报告的说明
在SonarQube中导入.NET报告分为4个步骤：
（1）运行SonarScanner.MSBuild.exe begin命令，使用/d:propertyKey="path"语法指定报告可用的绝对路径("propertyKey"取决于工具)。
（2）使用MSBuild构建您的项目
（3）运行您的测试工具，指示它在先前指定给MSBuild SonarQube运行器的相同位置生成一个报告
（4）运行SonarScanner.MSBuild.exe end命令

### 4.4 导入外部问题
此页面列出了与导入由外部第三方分析人员提出的问题相关的分析参数。有关更多其他参数，请参见分析参数。
SonarSource分析程序不运行外部分析程序或生成报告。它们只导入预生成的报告。下面您将找到用于导入由外部analzyers生成的报告的特定于语言和工具的分析参数。关于一些外部分析程序的其他特定于语言的详细信息可以在相关SonarSource语言分析程序的子目录中找到。
有些属性在路径中支持以下通配符。支持通配符的属性的注释将提到这一事实。如果备注中没有说明支持通配符，则说明不支持。
符号  释义
?   单个字符
*   任意数量的字符
**  任意数量的目录
除非另有说明，否则以下属性同时接受绝对路径和相对于项目根的路径。
语言  属性  附注
Apex    sonar.apex.pmd.reportPaths  以逗号分隔的指向PMD Apex的路径列表
CSS sonar.css.stylelint.reportPaths 以逗号分隔的指向StyleLint.io的报告
Go  sonar.go.govet.reportPaths  逗号分隔的GoVet报告路径列表
Go  sonar.go.golint.reportPaths 以逗号分隔的GoLint报告路径列表
Go  sonar.go.gometalinter.reportPaths   逗号分隔的到GoMetaLinter报告的路径列表
Java    sonar.java.spotbugs.reportPaths 以逗号分隔的指向SpotBugs、FindSecBugs或FindBugs报告的路径列表
Java    sonar.java.pmd.reportPaths  由逗号分隔的到PMD报告的路径列表
Java    sonar.java.checkstyle.reportPaths   以逗号分隔的指向Checkstyle报告的路径列表
JavaScript  sonar.eslint.reportPaths    以逗号分隔的JSON ESLint报告路径列表
Kotlin  sonar.androidLint.reportPaths   逗号分隔的AndroidLint报告路径列表
Kotlin  sonar.kotlin.detekt.reportPaths 以逗号分隔的Detekt路径列表
Python  sonar.python.pylint 到Pylint报告的路径。支持通配符
Python  sonar.python.pylint_config
sonar.python.pylint 默认情况下，如果您没有指定pylint报告的路径，SonarPython将为您执行pylint命令。使用sonar.python。在非默认位置使用pylint可执行文件。属性必须在windows上设置(即使是默认位置)，使用转义反斜杠或单斜杠(例如C:\\Python26\\Scripts\\pylint.bat, C:/Python26/Scripts/pylint.bat)。使用sonar.python。指定非默认pylint配置文件的相对或绝对路径。
Python  sonar.python.bandit.reportPaths 以逗号分隔的Bandit报告路径列表
Ruby    sonar.ruby.rubocop.reportPaths  以逗号分隔的Rubocop报告路径列表
Scala   sonar.scala.scalastyle.reportPaths  以逗号分隔的到Scalastyle的路径列表
Scala   sonar.scala.scapegoat.reportPaths   Scalastyle格式的由逗号分隔的Scapegoat报告的路径列表
Swift   sonar.swift.swiftLint.reportPaths   以逗号分隔的指向SwiftLint报告的JSON格式的路径列表
TypeScript  sonar.typescript.tslint.reportPaths JSON格式的TSLint报告的逗号分隔路径列表
关于外部.NET问题的说明
来自第三方分析程序的问题包含在MSBuild输出中，并默认导入到SonarQube中，因此不存在任何属性来启用该行为。相反，可以使用属性调整导入并停止导入这些问题。
注意,Roslyn问题严重性错误自动构建失败,并不推荐运行扫描仪MSBuild结束步骤如果MSBuild一步失败任何理由,因为它会导致一个本质上是空的分析,将关闭所有项目中悬而未决的问题。
语言  属性  附注
C#  sonar.cs.roslyn.ignoreIssues    设置为true可禁用外部问题的导入。默认值为false。
C#  sonar.cs.roslyn.bugCategories
sonar.cs.roslyn.vulnerabilityCategories
sonar.cs.roslyn.codeSmellCategories 以逗号分隔的类别列表，其问题应被分类为bug、漏洞或代码气味。
VB.NET  sonar.vbnet.roslyn.ignoreIssues 设置为true可禁用外部问题的导入。默认值为false。
VB.NET  sonar.vbnet.roslyn.bugCategories
sonar.vbnet.roslyn.vulnerabilityCategories
sonar.vbnet.roslyn.codeSmellCategories  以逗号分隔的类别列表，其问题应被分类为bug、漏洞或代码气味。


### 4.5 后台任务
后台任务可以是：
（1）分析报告的导入
（2）投资组合的计算
（3）项目的导入或导出
#### 4.5.1 扫描仪完成分析后会发生什么
直到相关的后台任务完成后，分析才算完成。尽管SonarScanner的日志显示执行成功，但是在后台任务完成之前，SonarQube项目中不会看到分析结果。在SonarScanner完成对代码的分析之后，分析的结果(源、问题、度量)——分析报告——被发送到SonarQube服务器，由计算引擎进行最终处理。分析报告按顺序排队和处理。
在项目级别，当有一个待处理的分析报告等待使用时，在标题中有一个“待处理”通知，紧挨着最近完成的分析的日期。
全局管理员可以在Administration > Projects > Background Tasks时查看当前队列。项目管理员可以在Administration > Background Tasks中查看项目的任务。

#### 4.5.2 我如何知道什么时候分析报告处理失败
后台任务通常会成功，但有时不寻常的情况会导致处理失败。例子包括:
（1）在处理来自非常大的项目的报告时耗尽内存
（2）在现有模块或项目的键与报表中的键之间发生冲突
（3）。。。
当这种情况发生时，失败状态将反映在项目主页上，但这需要有人注意它。您还可以选择在后台任务失败时通过电子邮件得到通知——在个人资料的通知部分，可以根据项目的不同，也可以在全局范围内通知您拥有管理权限的所有项目。

#### 4.5.3 如何诊断失败的后台任务
对于每个分析报告，都有一个下拉菜单，允许您访问“扫描仪上下文”，显示代码扫描运行时扫描仪的配置。
如果任务处理失败，将提供一个附加选项:“显示错误细节”，以获取后台任务处理失败的技术细节。

#### 4.5.4 如何取消待处理的分析报告
管理员可以通过单击以下来取消未完成的分析进程：
（1）在待定任务的每一行可用的红色“x”上
（2）在挂起的作业计数旁边的红色“批量取消”选项上。此按钮取消所有挂起的任务。
一旦开始处理一个报告，取消它就太迟了。

### 4.6 通用问题数据
SonarQube支持一种通用的导入格式，用于在代码中引发“外部”问题。它的目的是允许你从你最喜欢的linter导入问题，即使没有插件存在。
外部问题受到两个重要的限制：
（1）它们不能在SonarQube中管理;例如，没有能力将它们标记为假阳性。
（2）在SonarQube中无法管理引发这些问题的规则的激活。事实上，外部规则在规则页面中不可见，也不反映在任何质量概要文件中。
外部问题和引发这些问题的规则必须在linter的配置中进行管理。

#### 4.6.1 导入
分析参数sonar.externalIssuesReportPaths接受以逗号分隔的报表路径列表。
每个报告必须在顶层包含一个名为problems的问题对象数组。
问题领域：
（1）engineId - 字符串
（2）ruleId - 字符串
（3）primaryLocation - 位置对象
（4）type - 字符串。BUG，VULNERABILITY，CODE_SMELL中的一个
（5）severity - 字符串。BLOCKER, CRITICAL, MAJOR, MINOR, INFO中的一个
（6）effortMinutes - 整型。 可选的，默认值为0
（7）secondaryLocations - 位置对象数组，可选参数
位置字段：
（1）message - 字符串
（2）filepath - 字符串
（3）textRange - TextRange对象，仅可选用于辅助位置
TextRange 字段：
（1）startLine - 整型 1-indexed
（2）endLine - 整型，可选。 1-indexed
（3）startColumn - 整型，可选。 0-indexed
（4）endColumn - 整型，可选。 0-indexed

#### 4.6.2 示例
以下是预期格式的一个例子:
{ "issues": [
    {
      "engineId": "test",
      "ruleId": "rule1",
      "severity":"BLOCKER",
      "type":"CODE_SMELL",
      "primaryLocation": {
        "message": "fully-fleshed issue",
        "filePath": "sources/A.java",
        "textRange": {
          "startLine": 30,
          "endLine": 30,
          "startColumn": 9,
          "endColumn": 14
        }
      },
      "effortMinutes": 90,
      "secondaryLocations": [
        {
          "message": "cross-file 2ndary location",
          "filePath": "sources/B.java",
          "textRange": {
            "startLine": 10,
            "endLine": 10,
            "startColumn": 6,
            "endColumn": 38
          }
        }
      ]
    },
    {
      "engineId": "test",
      "ruleId": "rule2",
      "severity": "INFO",
      "type": "BUG",
      "primaryLocation": {
        "message": "minimal issue raised at file level",
        "filePath": "sources/Measure.java"
      }
    }
]}


### 4.7 通用测试数据
SonarQube支持用于测试覆盖和测试执行导入的通用格式。如果您的语言插件不支持覆盖率引擎的本地输出格式，那么只需将它们转换为这些格式。
#### 4.7.1 常规覆盖
报告路径应以逗号分隔的列表形式传递给：sonar.coverageReportPaths
sonar-generic-coverage.xsd描述支持的格式
<xs:schema>
  <xs:element name="coverage">
    <xs:complexType>
      <xs:sequence>
        <xs:element name="file" minOccurs="0" maxOccurs="unbounded">
          <xs:complexType>
            <xs:sequence>
              <xs:element name="lineToCover" minOccurs="0" maxOccurs="unbounded">
                <xs:complexType>
                  <xs:attribute name="lineNumber" type="xs:positiveInteger" use="required"/>
                  <xs:attribute name="covered" type="xs:boolean" use="required"/>
                  <xs:attribute name="branchesToCover" type="xs:nonNegativeInteger"/>
                  <xs:attribute name="coveredBranches" type="xs:nonNegativeInteger"/>
                </xs:complexType>
              </xs:element>
            </xs:sequence>
          <xs:attribute name="path" type="xs:string" use="required"/>
          </xs:complexType>
        </xs:element>
      </xs:sequence>
      <xs:attribute name="version" type="xs:positiveInteger" use="required"/>
    </xs:complexType>
  </xs:element>
</xs:schema>
与以下的类似：
<coverage version="1">
  <file path="xources/hello/NoConditions.xoo">
    <lineToCover lineNumber="6" covered="true"/>
    <lineToCover lineNumber="7" covered="false"/>
  </file>
  <file path="xources/hello/WithConditions.xoo">
    <lineToCover lineNumber="3" covered="true" branchesToCover="2" coveredBranches="1"/>
  </file>
</coverage>
根节点应该命名为coverage。它的version属性应该设置为1。
为每个可以被测试覆盖的文件插入一个file元素。它的path属性可以是绝对的，也可以是相对于模块的根的。在file元素中，为单元测试所覆盖的每一行插入一个lineToCover。它可以有以下属性：
（1）lineNumber (必选)
（2）covered (必选)：布尔值，标识测试是否命中该行
（3）branchesToCover (可选)：可覆盖的分支数
（4）coveredBranches (可选)：测试实际覆盖的分支数量

#### 4.7.2 常规执行
报告路径应以逗号分隔的列表形式传递给：sonar.testExecutionReportPaths
支持的格式如下：
<testExecutions version="1">
  <file path="testx/ClassOneTest.xoo">
    <testCase name="test1" duration="5"/>
    <testCase name="test2" duration="500">
      <skipped message="short message">other</skipped>
    </testCase>
    <testCase name="test3" duration="100">
      <failure message="short">stacktrace</failure>
    </testCase>
    <testCase name="test4" duration="500">
      <error message="short">stacktrace</error>
    </testCase>
  </file>
</testExecutions>
根节点应该命名为testexecution。它的version属性应该设置为1。
为每个测试文件插入一个file元素。它的path属性可以是绝对的，也可以是相对于模块的根的。
注意，与覆盖率报告不同，报告中出现的文件必须是测试文件名，而不是测试所覆盖的源代码文件。
在file元素中，为单元测试运行的每个测试插入一个测试用例。它可以有以下属性/子属性：
（1）testCase (必选)
name (必选): 测试用例的名称
duration (必选): 长整型(毫秒)
failure|error|skipped (可选): 如果测试不合格，则用一条消息和一长段描述报告原因
message (必选): 描述原因的短消息
stacktrace (可选): 包含关于故障|错误|跳过状态的详细信息的长消息

### 4.8 拉取分析请求
Pull Request analysis是Developer Edition或更高版本的一部分。

#### 4.8.1 质量阈

#### 4.8.2 分析参数配置

### 4.9 SCM集成
在代码分析期间收集SCM数据可以解锁SonarQube的许多特性：
（1）自动分配问题
（2）代码查看器中的代码注释(责备数据)
（3）scm驱动的新代码检测(帮助修复水泄漏)。在没有SCM数据的情况下，SonarQube使用分析日期(用于修改行的时间戳)来确定新代码。
SCM集成需要对单个SCM提供者的支持。默认情况下支持Git和SVN。对于其他SCM提供者，请参阅市场。
如果需要，可以通过管理设置在全局/项目级别关闭它。

#### 4.9.1 Git
Git集成支持开箱即用的纯Java实现，因此不需要在执行分析的机器上安装Git命令行工具。
如果项目根目录中有. git文件夹或其中一个父文件夹中有. git文件夹，那么在分析过程中就会自动检测Git。否则，可以使用- dsonar .sc .provider=git强制提供程序。此集成需要一个完整的克隆，以便能够收集所需的指责信息(请参阅已知问题)。如果检测到浅克隆，将会记录一个警告，并且不会尝试检索错误信息。
已知问题：
（1）Git不认为旧的“Mac”行结束符(CR)是新行。因此，blame操作包含的行数将少于SonarQube的预期，分析将失败。解决方案是固定行结束使用Windows (CR/LF)或Unix (LF)行结束。
（2）JGit不支持.mailmap文件在被指责期间“清理”电子邮件地址
高级信息：
插件使用JGit 4.9.0。JGit是Git客户机的纯Java实现。
如何调查责备期间的错误(只可能在Unix/Linux上)
如果在一个文件上执行blame时出现错误，这可能是JGit中的一个限制或bug。请按照以下步骤确认：
（1）下载独立的JGit命令行分发版
（2）尝试对违规文件执行blame命令:
chmod +x /path/to/org.eclipse.jgit.pgm-4.9.0.201710071750-r.sh /path/to/org.eclipse.jgit.pgm-4.9.0.201710071750-r.sh blame -w /path/to/offending/file
（3）如果您在分析过程中得到了相同的错误，那么这看起来确实像是JGit中的一个bug(尤其是如果您没有使用本机git命令行工具时)。请尝试使用最新版本的JGit执行前面的步骤，并向SonarQube社区论坛报告所有信息。

#### 4.9.2 Subversion
Subversion 1.6到1.9.x支持开箱即用的Subversion集成。
如果在项目根的父层次结构的某个位置有. svn文件夹，则会在分析期间自动检测SVN。否则，您可以使用-Dsonar.scm强制提供程序。provider=分析命令行上的svn。
已知问题：
如果你遇到以下错误：Caused by: org.tmatesoft.svn.core.SVNException: svn: E200007: Retrieval of mergeinfo unsupported by 'https://pmd.svn.sourceforge.net/svnroot/pmd/trunk/pmd/src/main/java/net/sourceforge/pmd/AbstractConfiguration.java';
这意味着SVN服务器没有宣传“mergeinfo”功能。你可以检查广告功能，只需连接到它:telnet <svn_server> 3690，这通常是因为您的SVN服务器不是>= 1.5，或者您的项目在服务器升级后没有正确迁移。也可能是服务器配置错误。
您应该尝试在服务器上运行svnadmin upgrade。有关更多信息，请阅读https://subversion.apache.org/docs/relea-notes/1.5.html # repos-updates。

## 5 分支
### 5.1 概述
分支分析可以作为Developer Edition或更高版本的一部分使用，（我们使用的社区版，暂不翻译收费内容）
分支分析允许您这样做
（1）分析长寿的分支
（2）分析短暂的分支
（3）当短生命期分支的状态受到影响时，通知外部系统

#### 5.1.1 分支类型

#### 5.1.2 分析

### 5.2 短线分支

### 5.3 长线分支

### 5.4 分支常见问题

## 6 用户指南

### 6.1 修复问题源

#### 6.1.1 什么是泄漏

想象一下，有一天你回到家，发现厨房地板上有一滩水。你看着，水坑慢慢变大。
你拿拖把了吗？或者你是否尝试着去找到漏水的根源然后修复它？很显然，你选择了找漏水的根源。
那么为什么代码质量会有所不同呢?当您用SonarQube分析一个应用程序并意识到它有很多技术债务时，下意识的反应通常是开始补救——要么开始补救，要么制定一个补救计划。这就像每天拖地一次，却忽略了水源。
通常在这种传统方法中，在发布定期代码质量审计结果之前，开发人员应该在发布之前对结果采取行动。这种方法可能在短期内有效，特别是在强有力的管理支持下，但在中长期内总是失败，因为：
（1）代码评审在这个过程中来得太晚了，没有利益相关者热衷于修复问题;每个人都想要发布新版本。
（2）开发人员通常会拒绝不了解项目上下文的外部团队提出的建议。顺便说一下，正在审查的代码已经过时了。
（3）这种方法明显缺乏对代码质量的所有权。谁拥有质量?没有人!
（4）审查的是整个应用程序在投入生产之前，显然不可能将相同的标准应用于所有应用程序。每个项目都要进行谈判，这会耗尽整个过程的可信度。
相反，为什么不将您在家里使用的简单逻辑应用于管理代码质量的方式呢?修复泄漏意味着将重点放在“新”代码上，即自上次发布以来添加或更改的代码。然后事情就简单多了:
（1）质量阈可以每天运行，通过它是可以实现的。在发布时没有什么意外。
（2）对于开发人员来说，很难对他们前一天引入的问题进行反击。相反，他们通常乐于在代码仍然新鲜的时候修复问题。
（3）代码质量有明确的所有权
（4）go/no-go的标准在应用程序之间是一致的，并且在团队之间共享。实际上，新代码就是新代码，不管它是在哪个应用程序中完成的
（5）成本并不重要，因为它是开发过程的一部分
另外，更改最多的代码具有最高的可维护性，而未更改的代码具有最低的可维护性，这非常有意义。由于软件的本质，以及我们不断对其进行修改的事实，债务自然会减少。它不在的地方就是它不需要在的地方。

#### 6.1.2 如何去做
SonarQube提供了两种主要工具来帮助您发现漏洞:
（1）新的代码度量显示当前代码和您在其历史中选择的特定点(通常是previous_version)之间度量的差异
（2）新代码主要是基于SCM的“指责”数据来检测的，这些数据从新代码周期(以前的“泄漏周期”)中的第一个分析开始，在需要时使用回退机制。有关更多细节，请参见SCM集成。
（3）质量阈允许您设置布尔阈值，用于对代码进行度量。将它们与不同的度量标准一起使用，以确保随着时间的推移，代码质量朝着正确的方向发展。

### 6.2 项目页面
项目主页是任何项目详情的入口点：
（1）项目的可发布状态
（2）其质量的当前状态
（3）自新代码周期开始以来所生成内容的质量。
项目页面回答了两个问题：
（1）我今天可以发布我的项目吗?
（2）如果没有，我应该改进什么以使项目通过质量检验关?
#### 6.2.1 我今天可以发布项目吗
由于质量阈是执行质量策略的最强大的工具，所以页面从项目的当前质量门状态开始。如果项目通过，将显示一个简单的绿色all-clear。
如果没有，则可以立即使用details和drill-down来快速识别出错的地方，每个错误条件都有一个部分，显示当前项目的值以及它应该是什么。与往常一样，您将能够单击当前值以进入钻取。

#### 6.2.2 我应该先修复哪些问题
由于提高项目质量的最佳方法是在新问题变得根深蒂固之前捕捉并修复它们，所以项目的第一个视图以新代码周期为中心，在项目主页右侧用黄色突出显示。项目空间页面显示了关键度量的高级摘要，包括当前值和它们的新代码周期值。
就在质量门信息下面，您有许多可靠性和安全性领域的旧问题和新问题，然后是可维护性领域。单击页面上的任何图形都将进入详细视图，无论是在度量页面还是在问题页面。
最重要的事情是开发人员必须确保屏幕黄色部分中的新问题得到确认、检查和修复，并确保测试覆盖了新代码，以帮助将来的回归。无论过去引入了多少问题，或者总体测试覆盖率有多低，关注新添加的问题将确保情况不会比您先前在生产中发布的版本更糟。
那么，您应该首先处理哪些问题:bug、漏洞或代码气味?这要看情况，因为答案取决于问题的性质。假设你有一个重复了5次的代码块的问题，在这个重复的代码块中，你有3个bug和5个安全问题。最好的方法可能是先修复重复，然后在新集中的位置解决bug和漏洞，而不是修复5次。
这就是为什么在开始解决问题之前，你需要复审一下你的新问题。

#### 6.2.3 常规操作
（1）如何在较低等级查看项目度量
项目级度量菜单项将您带到一个专用的子空间，在这里您可以看到所有的项目度量。选择一个度量来获得更多的细节。列表和树视图都可用于每个度量，树图可用于百分比和评级。
（2）如何才能看到一个项目中的所有问题
“项目级问题”菜单项将您带到一个特定于项目的问题页面，在这里您可以在更高级别上执行所有相同的操作。在这个页面上，您可以通过在创建日期方面选择New Code，轻松地将列表缩小到新代码期间引入的新问题。
（3）如何查看项目结构和代码
项目级代码菜单项带您进入项目结构的大纲。下钻查看目录中的文件，并选择一个文件查看其代码。
如果您的项目太大，无法通过钻井进行简单的勘探，那么此页面的搜索功能将会有所帮助。虽然主菜单中的全局搜索返回来自整个SonarQube实例的结果，但是代码页上的本地化搜索仅限于当前项目中的文件和目录。
（4）如何查看项目活动/历史
项目级活动菜单项将您带到在SonarQube中创建的项目上执行的代码扫描的完整列表。通过到那里，您可以跟踪质量门的发展，查看质量概要文件的更改，并知道何时扫描了代码的给定版本。
（5）如何才能轻松地发现项目中的风险
可视化允许您比较项目组件，并快速找出表示最大风险的组件。活动页面提供了几个预定义的可视化，您还可以使用您选择的指标创建自定义可视化。
（6）如何向同事推广我的计划
如果您的项目是公开可见的，那么您可以使用本机项目标识在外部工具和网站中进一步提升其状态。公共项目主页上的“获取项目标识”按钮允许您选择/微调您的标识，并提供它的URL。

### 6.3 应用程序（收费项目，暂不翻译）
应用程序可以作为企业版或以上版本的一部分使用。
### 6.4 文件夹Portfolios
（投资组合？此处不会翻译）
投资组合可以作为企业版或以上版本的一部分使用。

### 6.5 问题
在运行分析时，每当一段代码违反编码规则时，SonarQube就会引发一个问题。这组编码规则是通过项目中每种语言的相关质量概要文件定义的。
每个问题都有以下五种严重程度之一：
1、阻断：影响生产中应用程序行为的高概率Bug:内存泄漏、未关闭的JDBC连接、…代码必须立即修复。
2、严重：要么是一个低概率影响生产中应用程序行为的bug，要么是一个表示安全缺陷的问题:空catch块、SQL注入、……必须立即检查代码。
3、主要：严重影响开发人员生产力的质量缺陷:未发现的代码段、重复的代码块、未使用的参数、…
4、次要：质量缺陷会对开发人员的工作效率产生轻微的影响:行不应该太长，“switch”语句应该至少有3种情况，…
5、提示：既不是缺陷也不是质量缺陷，只是一个发现。
理想情况下，团队不会引入任何新问题(任何新的技术债务)。SonarLint可以帮助开发人员，因为它提供了执行本地分析的能力，在将代码推回到SCM之前检查代码。但在现实生活中，如果没有新的技术债务，就不可能总是编写代码，而且有时不值得这样做。
所以新问题就产生了。

#### 6.5.1 理解问题的上下文
有时候，一旦问题被指出来，它们就是不言自明的。例如，如果您的团队已经同意了一个单位较低的camelCase变量命名约定，并且在My_variable上提出了一个问题，那么您不需要很多上下文就可以理解这个问题。但是在其他情况下，上下文对于理解为什么要提出一个问题可能是至关重要的。这就是为什么SonarQube不仅支持显示问题消息的主要问题位置，而且还支持次要问题位置。例如，次要问题位置用于标记方法中的代码片段，这增加了方法的认知复杂性。
但有时候，仅仅罗列出一长串贡献路径（contributing locations）还不足以理解一个问题。例如，当可以在代码的某些路径上取消对空指针的引用时，您真正需要的是问题流。每个流都是一组辅助位置，它们按顺序排列，以显示发生问题的代码的确切路径。而且，由于代码中可能有多个路径，例如没有释放资源，所以SonarQube支持多个流。

#### 6.5.2 代码气味、Bug和漏洞问题的生命周期
（1）状态
创建之后，问题会在生命周期中流动，可能会出现以下五种状态:
开启-由SonarQube在新问题上设置
已确认-手动设置，以指示问题是有效的
已解决-手动设置，以指示下一个分析应关闭该问题
重开-当解决的问题实际上没有得到纠正时，由SonarQube自动设置
关闭-由SonarQube自动设置自动创建的问题。
（2）解决问题
关闭问题有两种路径
已修复-当后续分析显示问题已被纠正或文件不再可用时自动设置(从项目中删除、排除或重命名)
移除-当相关规则不再可用时自动设置。该规则可能不可用，因为它已经从质量概要文件中删除，或者因为底层插件已经卸载。
已解决问题有两种路径：
假阳性-手动设定
无需修复-手动设定
（3）工作流程
问题自动关闭(状态:关闭)时:
(任何状态的)问题已被正确修复=>分辨率:修复
一个问题不再存在，因为相关的编码规则已被取消或不再可用(即:插件已被删除)=>分辨率:已删除
问题自动重新打开(状态:重新打开)时:
一个手动解决为固定的问题(但解决方案不是假阳性)在随后的分析中显示仍然存在
（4）安全热点问题生命周期
安全热点问题具有专用的生命周期。它们不被认为是可操作的，必须由具有“管理安全热点”权限的用户进行审查。

#### 6.5.3 安全热点问题生命周期
安全热点问题具有专用的生命周期。它们不被认为是可操作的，必须由具有“管理安全热点”权限的用户进行审查。
（1）状态
创建之后，安全热点问题会在一个专用的生命周期中流动，可能出现以下四种状态之一:
打开-由SonarQube在新问题上设置
已解决（无需修复）-当安全审核员接受开发人员对手动漏洞所做的修复，或者当打开的热点或手动漏洞被安全审核员清除时，SonarQube自动设置。
复审-当开发人员请求安全审核员检查她对手动漏洞所做的修复时，自动设置
重开-设置当开发人员消除一个打开的手动漏洞时，或当安全审核员手动重新打开问题以便对已解决的问题运行新的审计时。
只有删除包含安全热点的代码时，才会关闭安全热点问题。如果从项目的质量概要文件中删除标识热点的规则，则还可能删除安全热点。

#### 6.5.4 理解什么是新问题
要确定问题的创建日期，在每次分析期间执行一个算法，以确定问题是新的还是以前存在的。该算法依赖于报告问题所在行的内容散列(不包括空格)。对于多行问题，使用第一行的散列。对于每个文件(在检测到文件重命名之后)，算法从以前的分析中获取问题的基本列表，并尝试将这些问题与新分析报告的原始问题列表匹配。该算法首先尝试使用最强大的证据进行匹配，然后返回到较弱的启发式。
（1）如果问题在相同的规则上，具有相同的行号和相同的行散列(但不一定具有相同的消息)>匹配
（2）检测块在文件中移动，然后如果问题在相同的(移动)行和相同的规则(但不一定是相同的消息)>匹配
（3）在相同的规则上，使用相同的消息和相同的行散列(但不一定是相同的行)>匹配
（4）在相同的规则上，使用相同的消息和相同的行号(但不一定使用相同的行散列)>匹配
（5）使用相同的规则和相同的行散列(但不是相同的消息和不同的行)>匹配
（6）是否存在匹配的已关闭问题>匹配并重新打开
不匹配的“base”问题作为已修复的问题进行关闭。
不匹配的“raw”问题定为新的问题

#### 6.5.5 理解问题的回溯
一旦一个问题被确定为如上所述的“新”问题，下一个问题就是给出它的日期。例如，如果它在代码中已经存在了很长时间，但是由于向概要文件添加了新规则，所以只能在最近的分析中找到它，该怎么办?这个问题应该给出最后一次更改的日期，还是给出第一次提出它的分析的日期?也就是说，它应该追溯吗?如果最后一次更改的日期是可用的(这需要SCM集成)，那么在某些情况下，这个问题将追溯到：
（1）对一个项目或分支的第一次分析
（2）当概要文件中的规则是新规则时(激活的全新规则或已停用但现在激活的规则)
（3）当分析器刚刚升级时(因为现在规则实现可以更智能)
（4）当规则是外部的
因此，回溯可能会将新提出的问题排除在新代码周期之外。

#### 6.5.6 自动问题分配
（1）用于BUG、漏洞和代码气味：
如果提交者可以与SonarQube用户关联，那么在分析过程中，新问题将自动分配给问题行上的最后一个提交者。请注意，目前无法自动分配文件之上任何级别的问题，例如目录/项目。
（2）用于安全热点
只有当通过“检测”操作将安全热点转换为漏洞时，才会自动分配问题。
（3）用户关联
自动生成登录和电子邮件关联。也就是说，如果用户提交了她的电子邮件地址，并且该电子邮件地址是她的SonarQube个人资料的一部分，那么在她是最后一个提交者的地方所提出的新问题将自动分配给她。
可以在用户的配置文件中手动进行附加关联(更多信息请参见授权中的“SCM帐户”)。
（4）已知的限制
如果与问题关联的SCM登录超过问题作者允许的255个字符，那么作者将被留空。

#### 6.5.7 问题编辑
SonarQube的问题工作流可以帮助您管理问题。对于一个问题，您可以做7件不同的事情(除了在代码中修复它!):注释、分配、确认、更改严重性、解析、不修复和False Positive。
这些行为可以分为三类。首先是“技术审查”类别。

##### 6.5.7.1 技术评审
Confirm、False Positive、Won't Fix、Severity change和Resolve操作都属于这一类，这类操作假定对某个问题进行初步审查，以验证其有效性。假设现在是回顾上一个回顾期间添加的技术债务的时候了——无论是一天、一周还是整个sprint。你看完每一期，然后做一个:
（1）Confirm ：通过确认一个问题，你基本上是在说“是的，这是个问题。”这样做将把它从“打开”状态移到“确认”状态。
（2）假阳性：从上下文来看这个问题，您会发现，不管出于什么原因，这个问题实际上并不是一个问题。所以你把它标记为假阳性，然后继续。要求管理项目上的问题权限。
（3）无需解决：在上下文中查看这个问题，您会发现虽然它是一个有效的问题，但实际上并不需要修复。换句话说，它代表了可接受的技术债务。所以你标记它不会修复然后继续。要求管理项目上的问题权限。
（4）严重程度的变化：这是前两个选项之间的中间地带。是的，这是一个问题，但它并不像规则默认的严重性所显示的那么糟糕。或者情况可能更糟。无论哪种方式，你都要调整问题的严重性，使之符合你认为它值得的程度。要求管理项目上的问题权限。
（5）解决：如果你认为你已经解决了一个悬而未决的问题，你可以解决它。如果您是正确的，那么下一个分析将把它移动到关闭状态。如果你错了，它的状态会重新打开。
此外，安全热点还允许以下功能：
（1）探测：确认安全热点为真实问题并手动打开漏洞。要求管理项目上的安全热点。
（2）清理：将安全热点或手动打开的漏洞标记为没有问题，不应该修复。要求管理项目上的安全热点。
（3）请求审查：要求安全审核员审查为纠正手动打开的漏洞所做的更改。
（4）驳回：检查后，拒绝对手动打开的漏洞进行修复，并将其返回到打开的问题。要求管理项目上的安全热点。
如果您倾向于将许多问题标记为False Positive或Won't Fix，这意味着一些编码规则不适合您的上下文。因此，您可以在质量概要文件中完全禁用它们，或者使用问题排除来缩小规则的焦点，这样就不会在应用程序的特定部分(或对象类型)上使用它们。类似地，进行大量的严重性更改应该会促使您考虑更新概要文件中的规则严重度。
当您编辑问题时，相关的度量标准(例如新的bug)将自动更新，如果相关，质量检验关状态也会自动更新。

##### 6.5.7.2 Dispositioning
一旦问题通过了技术审查，就应该决定谁来处理它们。默认情况下，它们被分配给问题行上的最后一个提交者(在提出问题时)，但是您当然可以将它们重新分配给您自己或其他人。如果受让人注册了任务通知，他将收到任务的电子邮件通知，任务将显示发现的所有问题，包括在我的账户中空间的我的问题列表中。

##### 6.5.7.3 一般情况
在问题生命周期的任何时候，您都可以对其进行日志注释。注释显示在运行日志中的问题细节中。您可以编辑或删除您所做的评论。
您还可以编辑问题的标记。问题继承创建它们的规则的标记，但是对问题设置的标记是完全可编辑的。可以为具有项目浏览权限的用户随意创建、添加和删除标记。
虽然它们最初是从相关规则继承的，但是问题上的标记并不与规则同步，因此向规则添加标记不会将这些标记添加到规则的问题中。

##### 6.5.7.4 批量变更
使用“问题搜索结果”窗格中的“批量更改”选项，可以同时对多个问题进行所有这些更改和更多更改。
默认情况下，已关闭的问题将保留30天。有关详细信息，请参见Housekeeping。

### 6.6 规则
#### 6.6.1 概要
在SonarQube中，分析程序提供在源代码上执行的规则来生成问题。有四种规则：
（1）代码气味(可维护性)
（2）BUG(可靠性)
（3）漏洞(安全性)
（4）安全热点(安全域)
对于代码气味和bug，零误报是预期的。至少这是目标，这样开发人员就不必担心是否需要修复。
对于漏洞，目标是有超过80%的问题是正确的。
安全热点规则的目的是吸引人们注意对安全性敏感的代码。预计超过80%的问题将在经过安全审核员的审查后以“无法修复”的形式迅速得到解决。
规则页面是您可以发现所有现有规则或基于提供的模板创建新规则的入口点。

#### 6.6.2 规则
默认情况下，当进入顶部菜单项“Rules”时，您将看到安装在SonarQube实例上的分析程序带来的所有可用规则。你可以根据左边窗格中的搜索条件缩小选择范围:
（1）语言:应用规则的语言。
（2）类型:Bug、漏洞、代码气味或安全热点规则。
（3）标记:可以向规则中添加标记，以便对它们进行分类并帮助更容易地发现它们。
（4）存储库:为SonarQube提供规则的引擎/分析器。
（5）默认严重性:规则的原始严重性——由提供此规则的分析器定义。
（6）状态:规则可以有3种不同的状态:
Beta版:该规则最近才实施，我们还没有从用户那里得到足够的反馈，所以可能会出现误报或误报。
弃用规则:不应该再使用该规则，因为存在类似但更强大和更准确的规则。
就绪:该规则已准备好在生产中使用。
（7）可用日期:第一次在SonarQube上添加规则的日期。例如，列出自插件上次升级以来的所有新规则是很有用的。
（8）模板:显示允许创建自定义规则的规则模板(请参阅本页面后面的内容)。
（9）质量概要:包含在或排除在特定概要中
如果选择了质量概要文件，还可以检查它的活动严重程度以及它是否继承。有关更多信息，请参见质量概要文档。

#### 6.6.3 规则详情
要查看规则的详细信息，可以单击它，或者使用右箭头键。除了基本的规则数据之外，您还可以查看哪些概要文件(如果有的话)是活动的，以及它引发了多少公开问题。
只有当您拥有正确的权限(“管理质量配置文件和门”)时，才可以使用以下两个操作:
（1）添加/删除标签:
①   可以在规则上添加现有标记，也可以创建新标记(在文本字段中输入新名称)。
②   注意，有些规则有不能删除的内置标记—它们是由提供规则的插件提供的。
（2）扩展描述:
①   扩展规则描述有助于让用户了解您的组织如何使用特定的规则，或者提供关于规则的更多信息。
②   注意，作为规则详细信息的一部分，扩展将对非管理员用户可用。

#### 6.6.4 规则模板和自定义规则
规则模板由插件提供，允许用户在SonarQube中定义自己的规则。例如，模板“体系结构约束”可用于创建任何类型的规则，用于检查从一组文件到另一组文件的禁止访问。
规则模板类似于cookie切割器，您可以从中删除新的“自定义规则”。要找到模板，请使用模板面:
 
要从模板创建自定义规则，您必须填写以下信息:
（1）名称
（2）关键字（自动关联）
（3）描述（支持MarkDown格式）
（4）默认的严重等级
（5）状态
（6）模板指定的参数
从模板导航到从中定义的自定义规则很容易:只需单击“自定义规则”部分中的链接，您就会看到给定规则的详细信息。
 

##### 6.6.4.1 用户自定义规则
自定义规则被认为与任何其他规则一样，除了它们可以被完全编辑甚至删除:
 
请注意，在删除自定义规则时，并没有从SonarQube实例中将其物理删除，而是将其状态设置为“remove”。这允许在SonarQube中正确显示与此规则相关的当前或旧问题，直到完全删除为止。

#### 6.6.5 扩展编码规则
可以添加自定义编码规则。有关详细信息和教程，请参见添加编码规则。

#### 6.6.6 规则类型和严重等级
##### 6.6.6.1 规则是如何分类的
SonarQube质量模型将规则分为四类:bug、漏洞、安全热点和代码气味。规则根据这些问题的答案分配到类别:
（1）关于代码的规则是明显错误的，还是更有可能是错误的?
如果答案是“是”，那么这就是一个错误规则。
如果不是……
（2）关于代码的规则会被黑客利用吗?
如果是这样，那么这就是一个漏洞规则。
如果不是……
（3）关于代码的规则是安全敏感的吗?
如果是，那么这就是一个安全热点规则。
如果不是……
（4）规则既不是Bug也不是漏洞吗?
如果这样，那么这就是一个代码气味规则。

#### 6.6.7 如何分配严重程度
为了给规则分配严重性，我们提出了一系列问题。第一个基本上是:
可能发生的最糟糕的事情是什么？
在回答这个问题时，我们试图在不预测世界末日的情况下引入墨菲定律。
然后我们评估最坏情况的影响和可能性(参见如何确定严重性和可能性)。，然后将答案填入真值表中:
    影响  可能性
阻断  √   √
严重  √   ×
主要  ×   √
次要  ×   ×

#### 6.6.8 如何决定严重程度和可能性
要评估规则的严重性，我们从最坏的情况开始(参见如何分配严重性)。，然后问一些分类明确的问题。
（1）Bugs
影响:最坏的情况会导致应用程序崩溃或损坏存储的数据吗?
可能性:最坏的事情发生的可能性是多少?
（2）漏洞
影响:利用最坏的东西会对您的资产或用户造成重大损害吗?
可能性:黑客能够利用最坏的东西的概率是多少?
（3）安全热点
安全热点没有分配严重程度，因为在安全审核员进行审查之前，还不知道是否存在真正的问题。当审核员将安全热点转换为漏洞时，根据已识别的漏洞分配严重性(见上文)。

### 6.7 与安全性相关的规则
SonarQube质量模型有三种不同类型的规则:可靠性(bug)、安全性(漏洞)和可维护性(代码气味)规则。但从另一个角度来看，只有两种类型:安全规则，以及所有其他类型。这两个群体之间的区别不在于他们捕获了什么，而在于他们来自哪里以及强加给他们的标准。

#### 6.7.1 期望从安全相关规则中得到什么
需要说明的是，在SonarQube语言插件中实现的大多数规则的标准都非常严格:没有假阳性。对于正常的规则，您应该能够确信，向您报告的任何问题实际上都是一个问题。
但对于与安全相关的规则，情况略有不同。例如，许多安全指南都讨论了应该如何处理“敏感”数据(例如不输出日志、不存储未加密的数据等等)。但是，由于在规则中实际上不可能区分哪些数据是敏感的，哪些不是，所以选择变成:维护无假阳性标准，不实现与安全相关的规则，或者使用不同的标准实现与安全相关的规则。
这就是为什么与安全相关的规则所覆盖的范围比您可能已经习惯看到的更广。其思想是，该规则将标记任何可疑的内容，并将其留给人工安全审核员来剔除假阳性，并将实际问题发送给修复人员。
安全热点是一种特殊类型的问题，它识别代码的敏感区域，安全审核员应该检查这些敏感区域，以确定它们是否是真正的漏洞。有关安全热点和审计过程的详细信息，请参阅安全审计和报告。

#### 6.7.2 与安全相关的规则从何而来
绝大多数与安全相关的规则源自已建立的标准:CWE、SANS Top 25和OWASP Top 10。要找到与这些标准相关的规则，可以通过标记或文本搜索规则。规则所涉及的标准将在规则描述底部的See部分中列出。

##### 6.7.2.1 CWE
CWE代表公共弱点枚举。根据CWE常见问题解答:
常见弱点枚举(Common Weakness Enumeration, CWE™)是一个正式的列表或字典，其  中列出了软件体系结构、设计、代码或实现中可能出现的常见软件弱点，这些弱点可能  导致可利用的安全漏洞。创建CWE的目的是作为描述软件安全弱点的通用语言;作为  针对这些弱点的软件安全工具的标准标尺;并为弱点识别、缓解和预防工作提供一个共  同的基线标准。
CWE是弱点描述的层次结构。层次结构中的最低级别是“弱点基础”，它描述了粒度上的弱点。弱点基础之上是弱点类和类别。一般来说，规则与薄弱基或类相关联。
满足特定要求的工具可以通过CWE兼容认证。这些要求是:
（1）您必须能够使用CWE标识符搜索与CWE相关的规则。要在SonarQube平台中做到这一点，只需在规则页面的搜索文本输入中删除CWE标识符(例如CWE-595)并运行搜索。
（2）规则必须与相关的CWE项目准确地链接。要查看SonarQube规则的CWE映射，请参阅规则描述底部的rule’s See部分。
（3）您必须能够从问题中识别出相关的CWE。要在SonarQube平台上这样做，请参考相关规则。
（4）产品文档必须包含对CWE和CWE兼容性的描述。
（5）必须列出所支持的CWE版本。SonarQube语言插件支持2.8版本。
（6）除了使用CWE id搜索规则外，还可以使用“CWE”规则标记进行搜索。
要查看语言包含哪些CWE项，请参考下面的链接。
C/C++
Java
Objective-C

##### 6.7.2.2 SANS Top 25
SANS Top 25列表是由SANS组织编制的CWE中列出的25个最危险的错误的集合。当前的san列表分为三类:组件之间不安全的交互、危险的资源管理和漏洞防御。
SANS使用的标签对应于它的类别:sans-top25-insecure, sans-top25-risky, sans-top25-porous.
要查找与SANS Top 25相关的规则，可以对类别或相关的CWE项执行文本搜索，或者执行规则标记搜索。

##### 6.7.2.3 OWASP Top 10
OWASP代表开放Web应用程序安全项目。根据它的网站，它是:
A 501(c)(3)世界范围内致力于提高软件安全性的非盈利慈善组织。我们的任务是使软件    安全可见，这样全世界的个人和组织就可以对真正的软件安全风险做出明智的决策。
OWASP Top 10是一个广泛的弱点类别列表，每个弱点都可以映射到许多单独的规则。
OWASP使用的标签对应于弱点类别:owasp-a1, owasp-a2, owasp-a3, owasp-a4, owasp-a5, owasp-a6, owasp-a7, owasp-a8, owasp-a9, owasp-a10.
要找到与OWASP Top 10相关的规则，可以对类别执行文本搜索，或者执行规则标记搜索。

### 6.8 内置规则标签
标签是一种对规则和问题进行分类的方法。问题继承了引发它们的规则上的标记。有些标签是特定于语言的，但更多的是跨语言出现的。用户可以向规则和问题添加标记，但是大多数规则都有一些开箱即用的标记。以下是一些内置标签的不全面的含义列表:
注意:下面到rules.sonarsource.com的链接最初将根据Java语言规则进行过滤
（1）brain-overload-一次要记住的东西太多了
（2）bad-practice-代码可能按照设计的方式工作，但是设计的方式被广泛认为是一个坏主意。
（3）cert-与CERT标准中的规则有关。目前有三种证书标准:C、c++和Java。其中许多规则不是特定于语言的，而是良好的编程实践。这就是为什么你会在非C/ C++， Java规则上看到这个标签。
（4）clumsy-额外的步骤用于完成一些可以更清晰、更简洁地完成的事情。(例如，在字符串上调用. tostring())。
（5）confusing-维护人员理解代码需要的时间会比代码实际执行的时间更长吗
（6）convention-编码约定——通常是格式化、命名、空格……
（7）cwe-与公共弱点枚举中的规则有关。有关CWE和一般安全相关规则的更多信息，请参见安全相关规则。
（8）design-代码的设计有些问题
（9）lock-in-使用特定于环境的特性
（10）misra-与MISRA标准中的一条规则有关。虽然MISRA规则主要是关于C和c++的，但其中许多规则并不是特定于语言的(例如，不要使用浮点数作为循环计数器)，而是简单的良好编程实践。这就是为什么您会在非C/ c++规则上看到这些标记。
（11）owasp-与OWASP十大安全标准中的一条规则有关。注意，OWASP Top Ten是一个高级漏洞列表，可以转换为许多潜在规则。
（12）pitfall-现在还没有什么问题，但是将来可能会出问题;已经为下一个家伙设好了陷阱，他很可能会掉进去，把代码搞砸。
（13）sans-top25-与SANS前25个编码错误有关，这些错误与安全性有关。注意，SANS Top 25列表是直接从CWE中提取的。
（14）suspicious-虽然不能保证这是一个bug，但是它看起来像一个可疑的bug。为了清晰起见，至少应该重新检查和重构代码。
（15）unpredictable-在当前条件下，代码可以很好地工作，但是如果条件发生变化，代码可能会不稳定地失败。
（16）unused-未使用的代码，例如从未使用的私有变量。
（17）user-experience-您的代码在技术上没有什么问题，但是它可能会让一些或所有用户讨厌您。

### 6.9 质量阈
#### 6.9.1 概要
质量检阈是在组织中实施质量政策的最佳方法。它的存在是为了回答一个问题:我今天能否将我的项目交付生产?
为了回答这个问题，您定义了一组基于度量阈值的布尔条件，这些阈值用于度量项目。例如:
（1）没有新的阻断问题
（2）新代码的代码覆盖率大于80%
（3）等等。。
理想情况下，所有项目都将根据相同的质量检验关进行验证，但这并不总是可行的。例如，你可能会发现:
（1）技术实现因应用程序而异(Web或Java应用程序的新代码可能不需要相同的代码覆盖率)。
（2）您希望确保对某些应用程序(例如，内部框架)有更强的需求。
（3）等等。。
这就是为什么您可以定义任意多的质量阈。质量阈是在顶部菜单中的质量阈页面中定义和管理的。

#### 6.9.2 使用最好的质量阈配置
质量阈“Sonar Way”由SonarSource提供，默认情况下是激活的，被认为是内置的，因此是只读的。它代表了我们对解决漏水问题的最佳方法的看法。在每个SonarQube版本中，我们都会根据SonarQube的功能自动调整这个默认的质量阈。
有三个度量标准允许您对可靠性、安全性和可维护性执行给定的评级，不仅是总体上的，还包括对新代码的评级。推荐使用这些指标，并将其作为默认质量阈的一部分。我们强烈建议您调整您自己的质量阈，以便使用它们向查看项目页面上的质量阈的开发人员提供更清晰的反馈。
不要忘记质量阈条件必须使用差分值。例如，没有必要检查绝对值，例如:代码行数大于1000。
推荐的质量阈：
大多数项目推荐Sonar Way内置质量阈。如果专注于保持新代码的整洁，而不是花费大量的精力来修复旧代码。开箱即用，它已经被设置为默认配置文件。

#### 6.9.3 质量阈状态
当前状态在项目页面顶部突出显示:
 

#### 6.9.4 当质量检查失败时得到通知
由于有了通知机制，用户可以在质量检查失败时得到通知。为此，订阅所有项目或您感兴趣的一组项目的新质量阈状态通知。

#### 6.9.5 安全性
任何用户(甚至匿名用户)都可以访问质量检验关。所有用户都可以查看质量门的各个方面。
要进行更改(创建、编辑或删除)，必须授予用户manage Quality Profiles和Gates权限。
项目管理员可以选择与他/她的项目相关联的质量检验关。有关更多信息，请参见项目设置。

#### 6.9.6 定义质量阈
要管理质量阈，请到质量阈(顶部菜单栏)。
每个质量阈条件都是下列条件的组合:
指标
比较运算符
错误值
例如，一个条件可能是:
指标:拦截器的问题
比较运算符:>
错误值：0
这可以表述为:没有阻塞问题。

### 6.10 指标定义
#### 6.10.1 复杂度
复杂度（complexity）
它是根据代码中的路径数计算的圈复杂度。每当一个函数的控制流分裂时，复杂度计数器就会增加1。每个函数的最小复杂度为1。这种计算因语言的不同而略有不同，因为关键字和函数是这样的。
特定于语言的细节
语言  说明
ABAP    下面的关键字增加了一个复杂度:AND, CATCH, CONTINUE, DO, ELSEIF, IF, LOOP, LOOPAT, OR, PROVIDE, SELECT…ENDSELECT, TRY, WHEN, WHILE
C/C++/Objective-C   函数定义，while, do while, for, throw语句，switch, case, default， &&运算符，||运算符?三元操作符，catch, break, continue, goto。
COBOL   下面的命令增加了一个复杂度(除非在copybook中使用):ALSO, ALTER, AND, DEPENDING, END_OF_PAGE, ENTRY, EOP, EXCEPTION, EXIT, GOBACK, CONTINUE, IF, INVALID, OR, OVERFLOW, SIZE, STOP, TIMES, UNTIL, USE, VARYING, WHEN, EXEC CICS HANDLE, EXEC CICS LINK, EXEC CICS XCTL, EXEC CICS RETURN
Java    关键词增加复杂度:if, for, while, case, catch, throw, &&, ||, ?
JavaScript, PHP 每个函数的复杂度增加1:function (例如非抽象和非匿名构造函数、函数、过程或方法)，if, short-circuit (AKA lazy) logical junction (&&)， short-circuit (AKA lazy) logical disjunction(||)，三元条件表达式，loop, switch语句的case子句，throw and catch语句，go to语句(仅适用于PHP)
PL/I    下面的关键字增加了一个复杂度:PROC, PROCEDURE, GOTO, GO TO, DO, IF, WHEN, |, !, |=, !=, &, &=
PL/SQL  复杂度增加1，因为:主要的PL / SQL匿名块(而不是内在的),创建过程,创建触发器,proceduredefinition,基本循环语句,whenclausestatement (simplecasestatement和searchedcasestatement)的“当”,continuestatement, cursorforloopstatement, continueexitwhenclause(“当”继续和退出语句的一部分),exceptionhandler(每个“何时”),exitstatement, forloopstatement, forallstatement, ifstatement, elsifclause, raisestatement, returnstatement,while eloopstatement, andexpression(和PL/SQ中使用的保留字)
VB.NET  复杂度增加了一个for:方法或构造函数声明(子、函数)，以及Case、Continue、End、Error、Exit、If、Loop、On Error、GoTo、OrElse、Resume、Stop、Throw、Try。
认识复杂度
理解代码的控制流有多难。请参阅《 the Cognitive Complexity White Paper》，以获得用于计算该度量的数学模型的完整描述。

#### 6.10.2 重复
重复块（duplicated_blocks）
重复的行块数。
对于要被视为重复的代码块：
非Java项目：
（1）应该至少有100个连续和重复的令牌。
（2）这些令牌应至少在以下方面传播：
①   COBOL的30行代码
②   ABAP的20行代码
③   其他语言的10行代码
JAVA项目：
无论标记和行数是多少，都应该至少有10个连续的和重复的语句。在检测重复时，忽略缩进和字符串文字的差异。
重复文件（duplicated_files）：
涉及复制的文件数量。
重复行（duplicated_lines）：
复制中涉及的行数。
重复行(%)(duplicate _lines_density)：
= duplicated_lines / lines * 100

#### 6.10.3 问题
新问题（new_violations）:
在新守则期内首次提出的问题数目。
新xxx问题(new_xxx_violations):
在新代码周期中首次提出的具有指定严重性的问题的数量，其中xxx是以下问题之一:阻断问题、关键问题、主要问题、次要问题、信息问题。
问题(violations)：
所有状态的问题总数
Xxx问题（xxx_issues）：
指定严重程度的问题的总数，其中xxx是其中之一:阻断问题、关键问题、主要问题、次要问题、信息。
假阳性问题(False _positive_issues)：
标记为假阳性的问题总数
开放问题(open_issues)
打开状态下的问题总数。
已确认问题(confirmed_issues)
确认状态下的问题总数。
重新开放问题(reopened_issues):
重新打开状态下的问题总数

#### 6.10.4 可维护性
代码味道(code_smells)：
代码气味问题的总数。
新代码气味(new_code_smell)：
在新代码周期中首次提出的代码气味问题的总数。
可维护性评级(sqale_rating)：
(以前是SQALE评级。)给您的项目的评级与您的技术债务比率的价值相关。默认可维护性评分网格为:A=0-0.05, B=0.06-0.1, C=0.11-0.20, D=0.21-0.5, E=0.51-1
维修性评定量表可交替表述为:
<=5%的时间已经进入应用程序，评级是A
在6%到10%之间的评级是B
在11%到20%之间的评级是C
在21 - 50%之间的评级是D
任何超过50%的都是E

技术债务(sqale_index)：
修复所有代码气味的工作。该度量以分钟为单位存储在数据库中。当以天为单位显示值时，假设一天工作8小时。
关于新代码的技术债(new_technical_debt)：
修复新代码周期中第一次提出的所有代码气味的工作。
技术负债率(sqale_debt_ratio)：
开发软件的成本与修复软件的成本之比。技术负债率公式为:
修复成本/开发成本
可以重申为:
补救成本/(开发一行代码的成本*代码行数)
开发一行代码的成本是0.06天。
新代码技术负债率(new_sqale_debt_ratio)
开发新代码期间更改的代码的成本与与之相关的问题的成本之比。

#### 6.10.5 质量阈
质量门状态(alert_status)
与项目相关联的质量检验关的状态。可能的值是:ERROR、OK， WARN状态已从7.6中删除。
质量门细节(quality_gate_details)
对于你的质量门的所有条件，你知道哪个条件是失败的，哪个不是。

#### 6.10.6 可靠性
Bugs(bugs):
Bug类问题的数量
新Bugs(new_bugs):
新bug问题的数量
可靠性评级(reliability_rating)：
A = 0 bug
B =至少有一个小错误
C =至少有一个主要Bug
D =至少有一个关键错误
E =至少有一个阻塞程序错误

可靠性补救工作(reliability_remediation_effort)
修复所有bug问题。该度量以分钟为单位存储在数据库中。当以天为单位显示值时，假设一天工作8小时。
对新代码的可靠性补救工作(new_reliability_ation_effort)
与可靠性补救工作相同，但是在新代码周期中对代码进行了更改。

#### 6.10.7 安全性
漏洞(vulnerabilities):
漏洞问题的数量
新漏洞(new_vulnerabilities):
新漏洞问题的数量
安全评级(security_rating)
A = 0漏洞
B =至少有1个小漏洞
C =至少有一个主要漏洞
D =至少1个关键漏洞
E =至少有一个拦截器漏洞
安全修复工作(security_ation_work)
修复所有漏洞问题的努力。该度量以分钟为单位存储在数据库中。当以天为单位显示值时，假设一天工作8小时。
新代码上的安全修复工作(new_security_ation_effort)
与安全修复工作相同，但是在新代码周期中更改了代码。

#### 6.10.8 大小
类（classes）
类的数量(包括嵌套类、接口、枚举和注释)。
注释行(comment_lines)
包含注释或已注释代码的行数。
不重要的注释行(空注释行、只包含特殊字符的注释行等)不会增加注释行数量。
以下代码包含9行注释:

> /**                                    +0 => empty comment line
>  *                                     +0 => empty comment line
>  * This is my documentation            +1 => significant comment
>  * although I don't                    +1 => significant comment
>  * have much                           +1 => significant comment
>  * to say                              +1 => significant comment
>  *                                     +0 => empty comment line
>  \**\**\**\**\**\**\**\**\**\**\**\**\**\*           +0 => non-significant comment
>  *                                     +0 => empty comment line
>  * blabla...                           +1 => significant comment
>  */                                    +0 => empty comment line
>   
> /**                                    +0 => empty comment line
>  * public String foo() {               +1 => commented-out code
>  *   System.out.println(message);      +1 => commented-out code
>  *   return message;                   +1 => commented-out code
>  * }                                   +1 => commented-out code
>  */                                    +0 => empty comment line

语言  说明
面向商业的通用语言   包含以下指令的行同时作为注释和代码行计算AUTHOR, INSTALLATION, DATE-COMPILED, DATE-WRITTEN, SECURITY.
JAVA语言  文件头不被计算为注释行(因为它们通常定义许可)。
注释行密度(%)(comment_lines_density)
注释行密度=注释行/(代码行+注释行)* 100
用这样一个公式:
50%表示代码行数等于注释行数
100%表示该文件只包含注释行

目录(directories)
数量的目录。

文件(files)
数量的文件。

代码行(ncloc)
包含至少一个字符的物理行数，该字符既不是空格，也不是表格，也不是注释的一部分。
语言  说明
面向商业的通用语言   生成的代码行和预处理指令(SKIP1、SKIP2、SKIP3、COPY、EJECT、REPLACE)不计算为代码行。
每种语言的代码行数(ncloc_language_distribution)
按语言分发的非注释代码行

函数(functions)
数量的功能。根据语言的不同，函数可以是函数、方法或段落。
语言  说明
面向商业的通用语言   它是段落的数量。
JAVA    匿名类中的方法将被忽略。
VB.NET  访问器不被认为是方法。
项目(projects)
投资组合中的项目数量
语句(statements)
语句的数量。

#### 6.10.9 测试
条件覆盖(branch_coverage)
在包含一些布尔表达式的每一行代码中，条件覆盖率简单地回答了以下问题:“是否将每个布尔表达式都计算为true和false?”这是单元测试执行期间遵循的流控制结构中可能的条件的密度。
条件覆盖= (CT + CF) / (2*B)
CT =至少一次被评估为“true”的条件
    CF =至少一次被评估为“false”的条件
    B =条件总数
新代码的条件覆盖率(new_branch_coverage)
与条件覆盖相同，但仅限于新的/更新的源代码。
条件覆盖命中(branch_coverage_hits_data)
承保条件清单。
按行条件(conditions_by_line)
按行数条件。
按行覆盖条件(covered_conditions_by_line)
按线路覆盖的条件数。

覆盖率(coverage)
它是线路覆盖和条件覆盖的混合。它的目标是为以下问题提供更精确的答案:单元测试覆盖了多少源代码?
覆盖率= (CT + CF + LC)/(2*B + EL)
CT =至少一次被评估为“true”的条件
    CF =至少一次被评估为“false”的条件
    LC =覆盖行= linestocover - uncovered_lines
    B =条件总数
    EL =可执行行总数(lines_to_cover)
新代码的覆盖率(new_coverage)
与覆盖范围相同，但仅限于新的/更新的源代码。
行覆盖率(line_coverage)
在给定的代码行上，行覆盖率简单地回答了以下问题:这行代码是在单元测试执行期间执行的吗?为单元测试所覆盖线的密度:
线路覆盖率= LC / EL
LC =覆盖行(lines_to_cover - uncovered_lines)
    EL =可执行行总数(lines_to_cover)
新代码的行覆盖率(new_line_coverage)
与行覆盖相同，但仅限于新的/更新的源代码。
行覆盖率命中(coverage_line_hits_data)
覆盖行列表。
要覆盖的行(lines_to_cover)
可以由单元测试覆盖的代码行数(例如，空白行或完整的注释行不被认为是要覆盖的行)。
要覆盖在新代码上的行(new_lines_to_cover)
与要覆盖的行相同，但仅限于新/更新的源代码。
跳过单元测试(skipped_tests)
跳过单元测试的次数。
发现条件(uncovered_conditions)
单元测试不包括的条件的数量。
新代码上未覆盖的条件(new_uncovered_conditions)
与未发现的条件相同，但仅限于新的/更新的源代码。
发现(uncovered_lines行)
单元测试不包括的代码行数。
新代码上未覆盖的行(new_uncovered_lines)
与未覆盖的行相同，但仅限于新的/更新的源代码。
单元测试(测试)
单元测试的数量。
单元测试持续时间(test_execution_time)
执行所有单元测试所需的时间。
单元测试错误(test_errors)
失败的单元测试的数量。
单元测试失败(test_failure)
由于意外异常而失败的单元测试数量。
单元测试成功密度(%)(test_success_density)
测试成功密度=(单元测试-(单元测试错误+单元测试失败))/单元测试* 100

### 6.11 概念
#### 6.11.1 架构
概念  定义
分析器 分析源代码以计算快照的客户机应用程序。
数据库 存储配置和快照
服务  用于浏览快照数据和更改配置的Web接口
请参阅SonarQube平台概述。

#### 6.11.2 质量
概念  定义
Bug 表示代码中某些错误的问题。如果这种局面还没有破裂，它就会破裂，而且很可能是在最糟糕的时刻。这个问题需要解决。昨天。
代码味道    代码中与可维护性相关的问题。让它保持原样意味着，在最好的情况下，维护人员将比他们应该对代码进行更改时遇到更大的困难。最坏的情况是，他们会对代码的状态感到非常困惑，以至于在进行更改时引入额外的错误。
成本  见修复成本
债务  见技术债务
问题  当一段代码不符合规则时，将在快照上记录一个问题。问题可以记录在源文件或单元测试文件上。有三种类型的问题:bug、代码气味和漏洞
度量  给定文件或项目在给定时间的度量值。例如，类MyClass上125行代码或项目myProject上30.5%的重复行密度
指标  一种测量方法。随着时间的推移，度量可以有不同的值或度量。例子:代码行数、复杂度等等。度量可以是定性的(给出组件的质量指示，例如重复行的密度、测试的行覆盖率等)，也可以是定量的(不给出组件的质量指示，例如代码行数、复杂度等)。
新代码段    在此期间，您将密切关注代码中引入的新问题。理想情况下，这是从previous_version开始的，但是如果您不使用类似maven的版本控制方案，您可能需要设置一个相对任意的时间段，比如21天或从一个特定的日期开始。
质量配置    一套规则。每个快照都基于单个质量概要文件。参见质量配置文件
规则  应遵循的编码标准或惯例。不遵守编码规则会导致错误、漏洞、安全热点和代码气味。规则可以检查代码文件或单元测试的质量。
修复的成本   修复漏洞和可靠性问题所需的估计时间。
快照  在给定的时间内对给定的项目的一组度量和问题。为每个分析生成一个快照。
安全热点    一个与安全相关的问题，突出显示使用安全敏感API的代码段(例如使用弱算法、连接到没有密码的数据库，……)。安全热点必须由安全审核员进行审查，审核员可能确定api的使用方式会引入漏洞。
技术债务    修复所有可维护性问题/代码气味所需的估计时间
漏洞  与安全相关的问题，表示攻击者的后门。参见与安全相关的规则。

### 6.12 活动和历史
项目活动页面提供了项目文件分析的全面列表(受内务管理的约束)，以及查看项目度量随时间变化的能力。
活动页面上的图表可以帮助您理解您所选择的三个度量之间的演化关系。图形鼠标悬停显示与特定分析相关的度量值和事件。

事件
四种类型事件：
质量阈 - 质量门的状态发生了变化。
概要文件 - 用于分析项目变更的质量概要文件-要么对概要文件进行编辑，要么使用不同的概要文件来分析项目。
版本 - 项目的版本更改了。
其他 - 在快照上手动创建事件。看到管理历史
事件显示在项目首页和项目活动页面中。

### 6.13 可视化
可视化可以帮助您更深入地了解项目的当前状态和历史。
#### 6.13.1 如何比较多个项目或项目组件的当前状态
项目空间允许您通过多个基于度量的标准筛选实例中的项目。一旦您选择了您的集合，您就不必盯着原始的数字来识别它的项目所面临的风险。相反，一些可视化(项目>透视图)可以帮助您了解每个项目在每个主要轴上的相对位置:
（1）风险-可靠性和安全等级，测试覆盖率，技术债务和代码行
（2）可靠性—可靠性评级、可靠性修复工作、代码行数和错误计数
（3）安全性—安全性评级、安全性修复工作、代码行数和漏洞计数
（4）可维护性——可维护性评级、技术债务、代码行数和代码气味计数
（5）覆盖率——覆盖率、复杂性和未覆盖的行
（6）重复-重复行%，代码行和重复块
（7）在项目级别，Measures选项卡中提供了这些相同的可视化，以帮助您比较项目组件。项目概览对应于项目空间中的风险可视化，对于其他五个图，选择相关域中的Overview选项。
此外，树状图还可用于项目级别的百分比和评级指标。使用右侧窗格中的透视图选择器在Measures选项卡中导航到它们。

#### 6.13.2 如何可视化指标历史
在项目级别，Activity选项卡提供了几个经过时间选择的度量的固定线形图，通过方便的鼠标切换可以显示图的详细信息，还可以轻松地将图缩小到项目历史的一个片段。除了固定的图表之外，您还可以在自定义图表中将您选择的指标彼此映射。

### 6.14 SonarLint智能通知
SonarLint智能通知可作为开发人员版或以上版本的一部分使用。
智能通知允许开发人员使用SonarLint的连接模式接收来自SonarQube的ide通知时:
（1）IDE中打开的项目/解决方案的质量门状态(失败/成功)
（2）SonarQube分析提出了这个开发人员在IDE中开放的项目/解决方案中引入的新问题

####6.14.1 激活/停用通知
通知的激活或停用必须单独完成，由SonarLint中的每个开发人员直接执行(在IDE端)。
接收通知可以在SonarLint端逐个服务器地配置SonarQube。

### 6.15 安全报告
#### 6.15.1 安全报告展示了什么
安全报告的设计目的是让您快速了解应用程序安全性的总体情况，其中列出了OWASP前10名、SANS前25名以及特定于cwe的详细信息。
安全报告由分析程序提供，分析程序依赖于在您的质量概要中激活的规则来提出安全问题。如果没有规则对应于给定OWASP类别激活你的质量档案,你会没有问题与特定的类别和等级显示将那并不意味着你是安全的范畴,但是,您需要激活更多的规则(假设存在)。

#### 6.15.2 热点和漏洞的区别是什么
漏洞是代码中容易受到攻击的点。安全热点是安全敏感的代码片段，应该由安全审核员仔细检查。这个人可以是:
（1）对安全问题更敏感的开发团队成员
（2）开发团队之外的某个人签约审查这些热点。
安全热点的主要目标是帮助安全审核员集中精力手工审查应用程序源代码。第二个目标是教育开发人员并提高他们的安全意识。应用程序中有热点并不意味着存在问题。它的真正含义是，一个人，最好是一个安全审核员/专家，应该检查代码，看看敏感代码段是否以最安全的方式使用。

#### 6.15.3 为什么一些热点和漏洞规则非常相似
它们是有意重叠的。Hotspot规则应该包含漏洞规则的所有匹配项，以及污染分析引擎无法检测漏洞的情况。例如，从一种语言切换到另一种语言(XML、JNI等)或使用一些第三方库将防止污染分析发现漏洞。漏洞规则只有在高度确定的情况下才会突出安全威胁，这意味着它总是会漏掉一些威胁。而Hotspot规则通过显示那些问题可能隐藏的代码来指导安全的代码审查，即使它不能检测到任何漏洞。

#### 6.15.4 为什么我看不到热点呢
以下是你可能看不到任何热点的三个原因:
（1）您可能真的没有它们，因为代码是在没有使用任何安全敏感API的情况下编写的。
（2）热点规则可能是可用的，但尚未在您的质量概要中激活，因此自然不会引发任何问题
（3）更有可能的情况是，您使用的语言分析器还没有提供热点规则，因此它不会引发任何热点，而不管实际存在多少个热点，但是最后一个选项将随着时间的推移而消失。

#### 6.15.5 为什么我看不到任何漏洞
由于或多或少与热点相同的原因，您可能看不到任何漏洞，但是对于漏洞来说，这可能更令人惊讶，因为您可能在项目主页上看到一些漏洞报告，而在安全报告中没有。这是因为语言分析器可能还没有提供在安全报告中显示问题所需的“安全标准”元数据。这个元数据基本上是一个规则(及其问题)与“OWASP Top 10”或“SANS Top 25”类别之间的链接。没有这个链接，就无法将已经存在的漏洞与安全标准类别关联起来，从而在报告中正确显示安全问题。SonarSource在2018年7月以后发布的每个分析仪版本都应该符合“安全标准”，并与热点问题类型兼容。

#### 6.15.6 我是一个开发人员。我应该关心热点吗
可能不会。热点地区本身并不是真正可以采取行动的。它们只是标记了潜在的问题，所以实际上不需要立即对代码执行任何操作。这就是为什么当热点问题出现时，您不会收到通知，并且在默认情况下热点不会显示在问题页面中。

#### 6.15.7 如果我的热点真的标志着一个漏洞
如果您查看引发热点的代码并意识到确实存在问题，那么单击当前状态(可能是打开状态)注册您已经检测到代码中的某个漏洞。一旦您这样做了，它将被转换为一个漏洞，最后一次触摸这一行的开发人员将收到“new issue”通知(如果她已经注册获得这些通知)。

#### 6.15.8 热点变成漏洞后会发生什么
一旦您发现热点位置确实存在问题，它将被分配给适当的开发人员，开发人员将进行修复，然后必须通过UI请求评审。该请求将问题从漏洞转移回Hotspot。从这里开始，就由安全审计人员决定接受或拒绝修复。接受修复将标记它不会修复，拒绝它将把它变成一个漏洞，把它放回开发人员的队列中。

#### 6.15.9 热点被标记为“无需修复”意味着什么
“不修复”的指定用于指示热点已被检查，目前还无法利用这段代码创建攻击。

### 6.16 用户账号
作为SonarQube的用户，你有自己的空间，在那里你可以看到与你相关的东西:
#### 6.16.1 主页
提供一个汇总页面：
（1）你所属的组
（2）你的SCM账户
#### 6.16.2 安全性
如果您的实例没有使用第三方身份验证机制，例如LDAP或OAuth提供者(GitHub、谷歌帐户，…)，则可以从这里更改密码。此外，您还可以管理自己的身份验证令牌。
您可以创建任意多的令牌。一旦创建了令牌，您就可以使用它对具有执行分析权限的项目执行分析。

### 6.17 用户令牌
每个用户都能够生成令牌，这些令牌可用于运行分析或调用web服务，而无需访问用户的实际凭据。
#### 6.17.1 如何生成一个令牌
生成一个令牌，去用户>我的帐户>安全。这里列出了您现有的令牌，每个令牌都有一个Revoke按钮。
页面底部的表单允许您生成新的令牌。单击“生成”按钮后，您将看到令牌值。立即将其复制;一旦您取消通知，您将无法检索它。
#### 6.17.2 如何使用令牌
用户令牌必须用来代替你通常的登入:
（1）运行代码分析时:用sonar中的令牌替换登录。登录属性。
（2）调用web服务时:在执行基本身份验证时，只需传递令牌而不是您的登录。
在这两种情况下，都不需要提供密码(因此，在对代码进行分析时，使用属性sonar)。密码是可选的)。

### 6.18 快捷键
#### 6.18.1 全局
快捷方式    动作
s   打开搜索栏
?   打开帮助

#### 6.18.2 代码页
快捷方式    动作
↑ ↓ 选择文件
→   打开文件
←   返回至文件列表
#### 6.18.3 问题页
快捷方式    动作
↑ ↓ 问题间切换
→   从问题列表转到源代码
←   返回至列表
Alt+↑ ↓ 浏览问题位置
Alt+←→  换流to switch flows
f   进行问题转换
a   分配问题
m   将问题分配给当前用户
i   更改问题严重程度
c   注释问题
Ctrl+Enter  提交注释
t   更改问题标签
#### 6.18.4 措施页面
快捷方式    动作
↑ ↓ 选择文件
→   打开文件
←   返回至列表
#### 6.18.5 规则页面
快捷方式    动作
↑ ↓ 规则间切换
→   从规则列表转到规则详情
←   返回至列表

### 7 项目管理
### 7.1 项目存在性
通常，项目是在第一次分析期间创建的，并且不会被删除(因为旧的软件不会死)。对于非典型情况，在Administration > Projects > Management中有一个页面，允许您管理项目的存在。

#### 7.1.1 如何在项目第一次分析之前提供项目
准备一个项目允许您在运行第一个分析之前声明和配置它(定义权限，设置质量概要文件，等等)。为了能够提供项目，您必须登录并获得提供项目的权限。
要提供一个新项目，要么使用顶部菜单中的“+”菜单，要么如果您具有全局管理权限，请转到administration > Projects > Management并单击Create project。唯一需要的信息是密钥和项目名称。
一旦准备好了项目，您就可以配置它(定义权限，设置质量概要文件，等等)，当您完成了配置之后，您就可以简单地运行项目的第一个分析。
您还可以使用Web API提供和配置项目。

#### 7.1.2 如何找到已准备好的项目(还没有分析)
项目管理搜索界面包含一个切换项，允许您将此页面上的结果缩小到从未分析过的项目。从这里，您可以在这个页面上作为一个集合来处理它们，或者单击到各个项目主页以获得个人的关注和管理。

#### 7.1.3 如何锁定项目的权限(私有和公共)
默认情况下，任何新创建的项目都将被认为是“公共的”。这意味着每一个SonarQube用户，无论身份验证与否，都可以:
（1）浏览:访问一个项目，浏览它的度量、问题并执行一些问题编辑(确认/解决/重新打开、分配、评论)。
（2）看源代码:查看项目的源代码。
如果您想确保只有有限的组和用户列表可以看到该项目，您需要将其标记为私有。一旦项目是私有的，您就可以定义哪些组和用户可以浏览项目或查看源代码。
如果希望所有新创建的项目都被认为是“私有的”，可以在管理>项目>管理中更改默认的可见性。

#### 7.1.4 如何删除项目
项目可以从项目的管理页面中单独删除。有关详细信息，请参见项目设置。若要批量删除项目，请使用管理>项目>管理。在这里，您可以选择要删除的项目。已删除的项目将永远消失，无法撤消此操作。

#### 7.1.5 如何找到不再被分析的项目
项目管理搜索界面包含一个日期选择器，可以帮助您找到在指定日期之前最后分析的所有项目。从这里，您可以在这个页面上作为一个集合来处理它们，或者单击到各个项目主页以获得个人的关注和管理。

### 7.2 管理项目历史
SonarQube最强大的特性之一是，它不仅显示了您当前的项目健康状况，还显示了随着时间的推移它是如何变化的。它通过有选择地保存以前分析的数据来做到这一点(请参阅内务管理)。它没有保留所有以前的分析—这会使数据库膨胀。同样，对于它保存的分析，SonarQube并不保存所有数据。
一旦项目快照从“最后的分析”(即最近的分析)转移到项目历史的一部分，项目级别以下的数据将被清除——同样是为了防止数据库膨胀。
通常这些都不是你需要考虑的;SonarQube会帮你处理。但有时您可能需要从项目的历史记录中删除一个糟糕的快照，或者更改管理算法。

#### 7.2.1 管理历史
有时候，您可能需要手动删除项目快照，可能是因为使用了错误的质量概要文件，也可能是因为分析存在问题，等等。注意，不能删除最近的快照(标记为“Last snapshot”)。
关于删除快照
删除快照需要两个步骤:
（1）必须首先通过单击Delete snapshot从项目历史记录中删除快照。它将不再显示在这个历史页面上，但仍然会出现在数据库中。
（2）快照实际上在下一次项目分析期间被删除。
在项目级别，从首页活动列表中选择Show More以查看完整的活动列表。
对于每个快照，可以手动:
（1）添加、重命名或删除版本
（2）添加、重命名或删除事件
（3）删除快照

### 7.3 缩小关注点
如果SonarQube的结果不相关，没有人会想要使用它。这就是为什么为每个项目精确配置要分析的内容是非常重要的一步。这样做可以消除干扰，比如标记在生成代码上的问题和重复，或者来自与特定类型的对象无关的规则的问题。
SonarQube为您提供了几个选项来精确配置将要分析的内容。你可以：
（1）完全忽略一些文件或目录
（2）将文件/目录排除在问题检测之外(特定规则或所有规则)，但分析所有其他方面
（3）排除文件/目录的重复检测，但分析所有其他方面
（4）从覆盖率计算中排除文件/目录，但分析所有其他方面
您可以在全局或项目级别进行这些更改。在这两个级别，导航路径是相同的:管理>一般设置>分析范围。

#### 7.3.1 忽略文件
我们建议您从库中排除生成的代码、源代码等。有四种不同的方法可以将您的分析缩小到与开发团队相关的源代码。您可以将它们组合在一起来调整您的分析范围。
（1）源码目录
设置sonar.sources将分析的范围限制为某些目录。
（2）文件后缀
大多数语言插件提供了一种方法，可以将分析的范围限制在与一组扩展名匹配的文件上。转到Administration > General Settings > [Language]设置文件后缀属性。
（3）选择文件
在你的分析中拥有一个界限清晰的文件设置在sonar.source的值是的第一道防线。对于使用Maven、Gradle或MSBuild构建和分析的项目，这个值是自动定义的，它具有一个全面而合理的值。在其他项目中，你需要去确认sonar.source设置为实际包含源文件的项目子目录。设置为 . 会撒下比大多数人想象的更大的网。
 

一旦您在分析中获得了您想要的所有文件，现在就可以查看您是否有任何您希望从分析中删除的文件，比如JavaScript库和生成的文件。这些可以通过排除处理。指定排除意味着将分析sonar.source目录下的所有东西。除具有与排除正则表达式匹配的路径的文件外。
 
要使用排除来分析除指定文件之外的所有内容，请转到“管理>常规设置>分析范围>文件”。
（1）源文件排除(sonar. exclusions) -排除源代码文件
（2）测试文件排除(sonar. Test .exclusions)-排除测试文件
绝大多数需求只需设置声纳即可满足。仔细的来源。大多数其他需求都是通过添加一些简单的除外责任来满足的。在少数情况下，有必要明确分析中包含的内容，并省略其他内容，但这不是通常的情况，在配置新项目时，不应该首先尝试设置包含内容。
 
在sonar系统中，使用除外责任只分析文件的指定子集。来源，转到管理>一般设置>分析范围>文件。
（1）源文件包含(sonar. inclusions)
（2）测试文件包含(sonar. test . inclusions)
您可以在项目和全局级别设置这些属性。
有关在这些输入中使用的语法的更多细节，请参见下面的Patterns部分。

#### 7.3.2 忽略问题
您可以让SonarQube忽略某些组件上的问题，并违反某些编码规则。进入管理>一般设置>分析范围>问题。
注意，下面的属性只能通过web接口设置，因为它们是多值的。
##### 7.3.2.1 忽略文件上的问题
您可以忽略包含匹配给定正则表达式的代码块的文件上的所有问题。
例如：
忽略文件中的包含“@javax.annotation.Generated”所有问题
@javax \ .annotation \ .Generated
##### 7.3.2.2 忽略块中的问题
您可以忽略特定代码块上的所有问题，同时继续扫描并标记文件其余部分上的问题。要忽略的块由start和end字符串分隔，这些字符串可以由正则表达式(或纯字符串)指定。
注意：
（1）如果找到了第一个正则表达式，但没有找到第二个正则表达式，则认为文件的末尾就是块的末尾。
（2）正则表达式不是在多行基础上匹配的。
##### 7.3.2.3 忽略多个标准上的问题
您可以忽略某些组件和某些编码规则上的问题。要列出特定的规则，请使用完全限定的规则ID。
您可以在规则定义上找到完全限定的规则ID。
例如：
（1）忽略所有文件上的所有问题
①   KEY = *
②   PATH = **/*
（2）忽略COBOL程序“bank/ZTR00021.cbl”上的所有问题
①   KEY = *
②   PATH = bank/ZTR00021.cbl
（3）忽略直接位于Java包“com”中的类的所有问题。，但不在它的子包中
①   KEY = *
②   PATH = com/foo/*
（4）忽略针对“对象”目录及其子目录中的文件的编码规则“cpp:Union”的所有问题
①   KEY = cpp:Union
②   PATH = object/**/*

##### 7.3.2.4 限制编码规则的范围
您可以将规则的应用程序限制为只适用于某些组件，而忽略所有其他组件。
例如：
（1）只检查“Bean”对象上的规则“Magic Number”，而不检查其他任何对象
①   KEY = checkstyle:com.puppycrawl.tools.checkstyle.checks.coding.MagicNumberCheck
②   PAYH = **/*Bean.java
（2）只检查位于“bank/creditcard”和“bank/bankcard”目录中的“防止转到语句将控制转移到COBOL程序的当前模块之外”规则。这需要两个标准来定义:
①   KEY #1 = cobol:COBOL.GotoTransferControlOutsideCurrentModuleCheck
②   PATH #1 = bank/creditcard/**/*
③   KEY #2 = cobol:COBOL.GotoTransferControlOutsideCurrentModuleCheck
④   PATH #2 = bank/bankcard/**/*

#### 7.3.3 忽略重复
您可以防止对某些文件进行重复检查。
为此，请转到管理>一般设置>分析范围>重复并设置重复排除属性。有关语法的更多细节，请参见Patterns部分。

#### 7.3.4 忽略代码覆盖率
您可以防止单元测试将一些文件考虑到代码覆盖率。
为此，转到管理>一般设置>分析范围>代码覆盖率，并设置覆盖率排除属性。有关语法的更多细节，请参见Patterns部分。

#### 7.3.5 Patterns
路径相对于项目基本目录。
可以使用以下通配符:
* - 0个或多个字符
** - 0个或多个目录
? - 一个字符
相对路径基于组件的完全限定名。
例如：
# Exclude all classes ending by "Bean"
# Matches org/sonar.api/MyBean.java, org/sonar/util/MyOtherBean.java, org/sonar/util/MyDTO.java, etc.
sonar.exclusions=**/*Bean.java,**/*DTO.java

# Exclude all classes in the "src/main/java/org/sonar" directory
# Matches src/main/java/org/sonar/MyClass.java, src/main/java/org/sonar/MyOtherClass.java
# But does not match src/main/java/org/sonar/util/MyClassUtil.java
sonar.exclusions=src/main/java/org/sonar/*

# Exclude all COBOL programs in the "bank" directory and its sub-directories
# Matches bank/ZTR00021.cbl, bank/data/CBR00354.cbl, bank/data/REM012345.cob
sonar.exclusions=bank/**/*

# Exclude all COBOL programs in the "bank" directory and its sub-directories whose extension is .cbl
# Matches bank/ZTR00021.cbl, bank/data/CBR00354.cbl
sonar.exclusions=bank/**/*.cbl

### 7.4 管理质量配置和应用程序
质量配置和应用程序可以在企业版进行获取。

#### 7.4.1 权限
具有创建项目组合或创建应用程序权限的用户可以从顶部菜单中的“+”项访问创建接口。
全局管理员可以在管理>配置>投资组合中访问整个质量配置和应用程序管理接口。可以从这个页面创建和编辑投资组合和应用程序。

### 7.5 质量配置PDF配置
Portfolio pdf是企业版或以上版本的一部分。

### 7.6 项目设置
#### 7.6.1 标签
项目标记允许您对项目进行分类和分组，以便在项目页面上更容易地进行选择。可以从项目主页管理项目标记。管理员将在项目的当前标记列表(或“No tags”指示符旁边)看到下拉菜单指示符。如果你想要的标签在下拉菜单中不可见，使用内置的“搜索”输入来找到你想要的或者动态创建它。

#### 7.6.2 项目管理
可以通过每个项目的管理菜单访问项目管理。
只有项目管理员才能访问项目的设置(请参阅授权)。

##### 7.6.2.1 增加一个项目
项目在第一次分析时自动添加。注意，您还可以提供项目。

##### 7.6.2.2 分析报告处理
在管理 >后台任务中有一个项目级的后台任务页面，允许项目管理员检查他们的项目的处理。它提供了详细的分析报告和日志。

##### 7.6.2.3 删除项目
你可以通过Administration > Deletion菜单来删除项目
同时注意项目也可以批量删除。

##### 7.6.2.4 设置新的代码周期
新代码周期可以通过管理>一般设置>新代码>新代码周期来根据每个项目进行设置。默认值是previous_version，对于定期发布版本的项目来说，这是最合适的值。对于其他项目，例如30天(输入“30”，理解“days”部分)可能更合适。
注意，这也可以在全局级别设置。

##### 7.6.2.5 更新项目的key值
可以在Administration > Update key上更新项目密钥(不丢失项目的历史记录)。
新密钥必须包含至少一个非数字字符。允许的字符有:'a'到'z'， 'A'到'Z'， '-'(破折号)，'_'(下划线)，'。'(点)，':'(冒号)和数字'0'到'9'。

##### 7.6.2.6 默认的问题分配人
当在分析过程中创建新问题时，它们被分配给提出问题的最后一个提交者。当无法确定最后一个提交者时，可以在Administration > General Settings > issues中将问题分配给默认的受让人。

##### 7.6.2.7 设置质量阈和质量配置
项目管理员可以选择以下，应用到项目：
质量配置(转到管理>质量配置)
质量阈(转到管理>质量阈)

##### 7.6.2.8 设置除外过滤
查看 7.3 节

##### 7.6.2.9 自定义链接
在只能设置为分析参数的标准链接之上，还可以通过web接口(管理下的>链接)添加额外的自定义链接。然后，这些链接将显示在项目页面中。

### 7.7 网络连接
当项目分析完成时，webhook通知外部服务。包含JSON有效负载的HTTP POST请求被发送到每个URL。url可以在项目级和全局级指定。项目级别的规范并不替代全局级别的web挂钩。调用两个级别的所有钩子。插件

HTTP(S)调用：
是否与后台任务的状态无关
使用POST方法将JSON文档作为有效负载
内容类型是否为“application/json”，并使用UTF-8编码

#### 7.7.1 配置
您可以在Administration > webhooks中配置最多10个webhook。
在管理>配置> webhooks中，可以在全局级别配置另外一组10个webhook。
如果配置好，所有20个都将执行。

#### 7.7.2 交付和有效载荷
交付
Webhook管理控制台显示每个Webhook最新交付的结果和时间戳，并通过列表图标提供有效负载。早期交付的结果和有效负载可以从每个webhook右侧的tools菜单中获得。
30天后清除响应记录。
URL必须在10秒内响应，否则交付将被标记为失败。

有效载荷
发送带有项目密钥的HTTP头“X-SonarQube-Project”，以便快速识别所涉及的项目
有效载荷是一个JSON文档，包括:
执行分析时:见“analysedAt”
分析项目的标识:见“project”
每项质量检验标准及其状态:见“qualityGate”
项目质量阈状态:见“qualityGate.status”
后台任务的状态和标识符:见“status”和“taskId”
用户指定的属性:参见“属性”

例如：
{
    "analysedAt": "2016-11-18T10:46:28+0100",
    "project": {
        "key": "org.sonarqube:example",
        "name": "Example"
    },
    "properties": {
    },
    "qualityGate": {
        "conditions": [
            {
                "errorThreshold": "1",
                "metric": "new_security_rating",
                "onLeakPeriod": true,
                "operator": "GREATER_THAN",
                "status": "OK",
                "value": "1"
            },
            {
                "errorThreshold": "1",
                "metric": "new_reliability_rating",
                "onLeakPeriod": true,
                "operator": "GREATER_THAN",
                "status": "OK",
                "value": "1"
            },
            {
                "errorThreshold": "1",
                "metric": "new_maintainability_rating",
                "onLeakPeriod": true,
                "operator": "GREATER_THAN",
                "status": "OK",
                "value": "1"
            },
            {
                "errorThreshold": "80",
                "metric": "new_coverage",
                "onLeakPeriod": true,
                "operator": "LESS_THAN",
                "status": "NO_VALUE"
            }
        ],
        "name": "SonarQube way",
        "status": "OK"
    },
    "serverUrl": "http://localhost:9000",
    "status": "SUCCESS",
    "taskId": "AVh21JS2JepAEhwQ-b3u"
}

### 7.8 额外参数
通过在Webhook的URL中提供用户/密码，例如https://myLogin:myPassword@my_server/foo，可以支持基本的身份验证机制。
如果使用模式sonar.analysis.*为SonarScanner提供附加属性。这些属性将自动添加到负载的“属性”部分。
例如，这些附加参数:
sonar-scanner -Dsonar.analysis.scmRevision=628f5175ada0d685fd7164baa7c6382c1f25cab4 -Dsonar.analysis.buildNumber=12345
会将此添加到有效载荷:
"properties": { "sonar.analysis.scmRevision": "628f5175ada0d685fd7164baa7c6382c1f25cab4", "sonar.analysis.buildNumber": "12345" }

## 8 实例管理
### 8.1 质量配置
#### 8.1.2 概要
质量概要服务是SonarQube的核心，因为它是通过定义一组规则来定义需求的地方(例如:方法的认知复杂性不应该大于15)。
理想情况下，对于任何给定的语言，所有项目都将使用相同的概要文件进行度量，但这并不总是实用的。例如，你可能会发现:
（1） 技术实现因应用程序而异(例如，在构建线程或非线程Java应用程序时可能应用不同的编码规则)。
（2） 您希望确保对某些应用程序(例如，内部框架)有更强的需求。
这就是为什么您可以定义尽可能多的质量概要文件，尽管建议尽可能少的质量概要文件，以确保公司中各个项目之间的一致性。要管理质量概要文件，请转到质量概要文件，在那里您将发现按语言分组的概要文件。
每个语言插件都有一个预定义的内置配置文件(通常称为“Sonar way”)，这样您就可以非常快速地开始SonarQube分析。这就是为什么一旦你安装了一个新的语言插件，至少有一个高质量的配置文件将为你提供。每种语言都必须有一个默认配置文件(用默认标记)。与特定概要文件没有显式关联的项目将使用该语言的默认概要文件进行分析。
在开始一个新的安装时，很容易使用Sonar方法作为默认配置文件，因为它包含了适用于大多数项目的所有规则。但是作为一个最佳实践，您应该创建一个新的概要文件(您可以通过复制Sonar方法的内容来填充它)并使用它。为什么? 首先，因为Sonar方法的概要文件是不可编辑的，所以您无法根据需要定制它。此外，这让您可以将Sonar方法视为一个基线，在您对其进行更改时，您可以根据该基线跟踪自己的配置文件(您将会这样做)。另外，Sonar方法通常会随着插件的每个新版本进行更新，以添加规则，有时还会调整规则的严重度。任何从内置声纳方法继承的概要文件实际上都将同时自动更新。

#### 8.1.3 将质量档案的管理委托给其他人?
默认情况下，只有具有“管理质量概要文件”权限的用户才能编辑质量概要文件。但是在大型组织中，可能不希望不加区别地授予更改所有质量概要文件的权限。这就是为什么您还可以授予用户/组编辑单个质量概要文件的权限，以便，例如，Swift概要文件的管理可以委托给一组Swift专家，COBOL也是如此，……
此权限的授权只能由已经拥有“管理质量概要文件”权限的人执行，或者在概要文件上拥有个人编辑权限的人执行，这些权限应该被授予其他权限。配置文件详细信息页面上提供了授予个人权限的接口。

#### 8.1.4 将规则从一个概要文件复制到另一个概要文件?
很多时候，人们希望使用基于内置配置文件的配置文件，而不是实际使用内置配置文件。在这种情况下，最简单的方法是在Quality Profiles中找到原始概要文件，我们称之为Source。然后，单击Source中的规则总数，以在规则页面上预先缩小搜索源规则的范围。使用批量激活打开目标配置文件中的源规则。

#### 8.1.5 了解规则文件中发生了什么变化？
当SonarQube注意到使用与前面的分析在某些方面不同的概要文件执行分析时，质量概要文件事件将添加到项目的事件日志中。要查看概要文件中的更改，请导航到概要文件(Quality Profiles >[概要文件名称])，并选择Changelog。这可以帮助您理解概要更改如何影响分析中提出的问题。
此外，具有质量配置文件管理特权的用户在每次更新内置配置文件(由分析人员直接提供的配置文件)时都会收到电子邮件通知。这些更新只能由分析器更新引起。

#### 8.1.6 将一个概要文件从一个SonarQube实例复制到另一个?
使用源实例上的备份功能将概要文件导出到XML文件。使用目标实例上的还原概要文件特性导入文件。注意，这个特性存在一些限制。

#### 8.1.7 在项目中应用核心规则集和附加规则?
假设您的公司有一组所有团队都必须遵守的最低编码规则，但是您希望在项目中添加特定于正在使用的技术的规则。这些规则对你的团队是有好处的，但对其他人来说却无关紧要，甚至会产生误导。这种情况需要继承。设置一个基本概要文件，我们将它命名为Root，并使用您的核心规则集。然后创建一个子配置文件，我们将其命名为Sprout。创建后，可以将parent更改为从Root继承，然后添加缺少的规则。

#### 8.1.8 确保我的非默认配置文件是用于一个项目?
每种语言的一个配置文件都被标记为默认配置文件。除非进行任何其他干预，否则使用该语言的所有项目都将使用该概要文件进行分析。要使用非默认概要文件分析项目，请从质量概要文件开始，单击目标概要文件，然后使用接口的Projects部分来管理显式分配给概要文件的项目。

#### 8.1.9 确保我获取概要文件中的所有相关的新规则?
每次发布一个语言插件更新时，都会添加新的规则，但是它们不会自动出现在您的概要文件中，除非您使用的是内置概要文件(如Sonarway规则)。
如果您没有使用内置配置文件，您可以将您的配置文件与内置配置文件进行比较，以查看您缺少哪些新的默认打开规则。
另一种选择是进入规则空间，使用可用的Since search facet查看自升级相关插件之日起添加了哪些规则。
最后，profile接口本身将帮助您了解在接口右侧最新的new rules部分中添加到新插件版本中的规则。

#### 8.1.10 比较两个概要文件
从Quality Profiles页面开始，单击想要比较的概要文件之一，然后使用Actions > compare接口选择第二个概要文件，并查看差异。

#### 8.1.11 确保质量配置中没有已弃用的规则
Rules接口本身的Deprecated Rules部分是对概要文件包含Deprecated规则的第一个警告。这个粉红色背景部分给出了概要文件中当前活动的已废弃规则的实例总数，以及每个概要文件中已废弃规则数量的细分。这里的单击进入Rules页面来编辑相关的概要文件。
或者，您可以执行规则搜索概要文件中的规则(手动或通过单击Quality Profiles页面)，并使用状态规则搜索方面将列表缩小到需要注意的部分。

#### 8.1.12 安全性
任何用户(甚至匿名用户)都可以访问Quality Profiles服务。所有用户都可以查看概要文件的各个方面。这意味着任何人都可以查看概要文件中包含哪些规则，哪些规则被遗漏了，查看概要文件随着时间的推移发生了怎样的变化，并比较任意两个概要文件中的规则。
要对规则概要文件进行更改(创建、编辑或删除)，必须授予用户manage Quality概要文件和Gates权限。
项目管理员可以选择与他的项目关联的概要文件。有关更多信息，请参见项目设置。

### 8.2 安全性
#### 8.2.1 概要
SonarQube有很多全局安全功能:
（1） 机载认证和授权机制
（2） 强制用户在看到SonarQube实例的任何部分之前进行身份验证的能力
（3）  委托到身份验证的能力(更多信息请参见委托身份验证)
此外，您还可以在组或用户级配置以下人员:
（1） 查看曾经是否存在过这个项目
（2） 访问项目的源代码
（3） 管理一个项目(设置排除模式，为该项目调优插件配置，等等)
（4） 管理质量概要文件、质量门和SonarQube实例本身。
安全性的另一个方面是对设置(如密码)进行加密。SonarQube提供了一个内置的机制来加密设置。

#### 8.2.1 身份认证
在为SonarQube设置安全策略时，应该回答的第一个问题是:匿名用户可以浏览SonarQube实例吗?还是需要身份验证? 
要强制用户身份验证，请以系统管理员身份登录，转到Administration > Configuration > General Settings > Security，并将强制用户身份验证属性设置为true。
SonarQube不支持跨多个用户共享电子邮件地址。

##### 8.2.1.1 身份验证机制
认证可以通过以下几种机制进行管理:
（1） 通过SonarQube内置的用户/组数据库
（2） 通过外部身份提供者，如LDAP服务器(包括Active Directory的LDAP服务)、GitHub等。参见插件库的身份验证和授权部分。
（3） 通过HTTP标头

##### 8.2.1.2 技术用户
当您在SonarQube自己的数据库中创建一个用户时，它被认为是本地的，并且只针对SonarQube自己的用户/组数据库进行身份验证，而不是针对任何外部工具(LDAP、Active Directory、Crowd等)。默认情况下admin是一个本地帐户。
类似地，所有非本地帐户将仅根据外部工具进行身份验证。
管理员可以通过Administration > Security > Users管理令牌。从这里，单击用户的令牌列，查看用户现有的令牌，并撤销现有的令牌或生成新的令牌。一旦建立，令牌就是运行分析所需的惟一凭证。令牌可以通过sonar.login属性进行传递

##### 8.2.1.3 默认管理员证书
安装SonarQube时，会自动创建一个具有管理系统权限的默认用户:
用户名：admin
密码：admin

#### 8.2.2 恢复管理访问
如果您更改并丢失了管理员密码，您可以使用以下查询重置密码:
update users set crypted_password = '$2a$12$uCkkXmhW5ThVK8mpBvnXOOJRLd64LJeHTeCkSuB3lfaR2N0AYBaSi', salt=null, hash_method='BCRYPT' where login = 'admin'
如果您删除了admin，并随后锁定了具有全局管理权限的其他用户，则需要使用以下查询将admin重新授予用户:
INSERT INTO user_roles(user_id, role) VALUES ((select id from users where login='mylogin'), 'admin');

#### 8.2.3 授权
SonarQube中实现授权的方式非常标准。可以根据需要创建尽可能多的用户和用户组。然后可以将用户附加(或不附加)到(多个)组。然后，组和/或用户被授予(多个)权限。权限授予对项目、服务和功能的访问权。
要管理组和用户，请选择Administration > Security，并使用子菜单项。

##### 8.2.3.1 用户
允许授权身份验证的多种集成是可用的(请参阅设置>安全性>用户)。对于手工创建的用户，可以在创建时设置登录和密码。手动创建的用户可以编辑他们的密码。
在用户创建和编辑期间，都可以设置帐户的屏幕名、电子邮件地址。用户登录和电子邮件地址将被问题分配特性隐式地识别为SCM帐户(如果适用的话)，但是您可以显式地设置额外的SCM帐户。

##### 8.2.3.2 组
组是一组用户。
要管理组，请访问Administration > Security >Groups。
若要编辑组成员关系，请单击成员总数旁边的图标。
两组有一个特殊的含义:
（1） Anyone是系统中存在的一个组，但是不能被管理。每个用户都属于这个组，包括匿名用户。
（2） sonar-users是自动添加用户的默认组。

##### 8.2.3.3 全局权限
要设置全局权限，请以系统管理员身份登录并转到Administration > Security >Global Permissions。
（1） Administer System:实例的所有管理功能:全局配置。
（2） Administer Quality Profiles：任何关于质量配置的行动。
（3） Administer Quality Gates: 对质量检验关采取任何行动
（4） Execute Analysis: 执行分析(项目、视图、报告、开发人员)，并获得执行分析所需的所有设置，甚至是scm帐户密码等安全设置。
（5） Create Projects: 在第一次分析之前初始化新项目的结构。在对尚未通过GUI 创建的项目进行第一次分析时也需要该权限。* **
（6） Create Applications: 创建一个新的应用程序.*  * *
（7） Create Portfolios: 创建一个新的质量概要文件.*  * *
*拥有显式创建权限的用户将在顶部菜单中看到一个“+”项，允许访问这些函数。如果从全局管理员中删除这些权限，它们将失去通过“+”菜单对它们的快速访问，但保留通过“管理”菜单对创建的访问。
**创建项目不会自动授予管理该项目的权限。为此，请参见下面的创建者权限。

##### 8.2.3.4 项目权限
项目权限可从项目级管理菜单中获得:管理>权限。
项目可见性可以在公共或私有之间切换。将项目设置为私有会向Anyone组隐藏其源代码和度量。对于公共和私人项目，可以设置四种不同的权限:
（1） Administer Issues: 更改问题的类型和严重性，将问题解决为“无法修复”或“假阳性”(用户还需要“浏览”权限)。
（2） Administer Security Hotspots: 从“安全热点”“检测”(转换)漏洞，拒绝、清除、接受或重新打开“安全热点”(用户还需要“浏览”权限)。
（3） Administer: 访问项目设置并执行管理任务(用户还需要“浏览”权限)。
（4） Execute Analysis: 执行分析(项目、视图、报告、开发人员)，并获得执行分析所需的所有设置，甚至包括scm帐户密码、jira帐户密码等安全设置。
私有项目有两个额外的权限:
（1） Browse: 访问一个项目，浏览它的度量、问题并执行一些问题编辑(确认/解决/重新打开、分配、注释)。
（2） See Source Code: 查看项目的源代码。
注意，权限不是累积的。例如，如果希望能够管理项目，还必须授予Browse权限才能访问项目(这是公共项目的默认权限)。
您可以手动将每个项目的权限授予某些用户和组，也可以将权限模板应用于项目。

#### 8.2.4 默认权限的权限模板
SonarQube附带一个默认的权限模板，该模板在创建项目、投资组合或应用程序时自动向特定组授予特定的权限。可以编辑此模板，并创建其他模板。可以为每种类型的资源设置单独的模板。此外，对于项目，可以使用项目键正则表达式(模板的项目键模式)将模板仅应用于新项目的子集。默认情况下，每个具有匹配所提供模式的键的新项目都将应用template的权限。
模板创建后立即为空。单击模板名称将进入它的权限编辑界面。
模板通过管理>安全性>权限模板进行管理。

##### 8.2.4.1 创建者权限
创建者是仅出现在权限模板编辑界面中的特殊组。在创建项目/投资组合/应用程序时，分配给这个组的任何权限都将被授予用于创建项目的单个用户帐户。这允许SonarQube管理员允许用户自主创建和管理自己的项目。
虽然模板可以在项目创建之后应用，但是对现有的项目/投资组合/应用程序应用包含“创建者”权限的模板将不会向项目的原始创建者授予相关的权限，因为该关联没有存储。

##### 8.2.4.2 将项目权限重置为模板
要将权限模板应用于项目，请转到管理>项目>管理。您可以使用特定于项目的操作> apply Permission template选项将模板应用于特定的项目，或者使用Bulk apply Permission模板将模板应用于所有选定的项目。
请注意，项目和权限模板之间没有关系，这意味着:
（1） 将权限模板应用于此项目后，可以修改项目的权限
（2） 在修改权限模板时，不会更改任何项目权限

#### 8.2.5 设置加密
加密主要用于从设置中删除清晰的密码(例如，数据库或SCM凭证)。所实现的解决方案基于一种对称密钥算法。关键是密钥存储在磁盘上的安全文件中。这个文件必须由运行SonarQube服务器的系统帐户拥有，并且只有该帐户可读。
算法为AES 128位。注意，256位密码没有使用，因为所有Java虚拟机默认不支持它(请参阅本文)。
（1） 生成密钥
必须在SonarQube基础设施的所有部分(服务器和分析程序)之间共享唯一的密钥。要生成它，请转到Administration > Configuration > Encryption并单击generate Secret Key。
（2） 将密钥存储在SonarQube服务器上
a)  将生成的secred密钥复制到托管SonarQube服务器的机器上的文件中。默认位置是~/.sonar/sonar-secret.txt。如果你想把它储存在其他地方，设置它通过声纳的路径。secretKeyPath属性位于$SONARQUBE-HOME/conf/sonar.properties中
b)  将文件权限限制为运行SonarQube服务器的帐户(仅限所有权和读访问)。
c)  重启SonarQube服务器
（3） 生成您的设置的加密值
回到管理>配置>加密，并使用已添加到接口的表单生成值的加密版本。
 
（4） 在SonarQube服务器配置中使用加密的值
只需将这些加密的值复制到$SONARQUBE-HOME/conf/sonar.properties中
sonar.jdbc.password={aes}CCGCFg4Xpm6r+PiJb1Swfg== # Encrypted DB password ... sonar.secretKeyPath=C:/path/to/my/secure/location/my_secret_key.txt

### 8.3授权认证
SonarQube附带一个板载用户数据库，以及通过HTTP头文件或LDAP委托身份验证的能力。

#### 8.3.1 HTTP报头身份验证
此功能旨在将用户身份验证委托给第三方系统(代理/服务器)。
当此功能被激活时，SonarQube期望在任何查询到达服务器之前处理身份验证。处理认证的工具应:
（1） 拦截对SonarQube服务器的调用
（2） 处理身份验证
（3） 使用相关的SonarQube用户信息更新HTTP请求头
（4） 使用适当的头信息将请求重路由到SonarQube
 
激活和配置该特性所需的所有参数都可以在SonarQube服务器配置文件中找到(在$ SonarQube - home /conf/sonar.properties中)。
使用Http报头身份验证是将SonarQube部署与内部SSO实现集成的一种简单方法。

#### 8.3.2 LDAP认证
通过在$ SonarQube - home /conf/sonar.properties中配置正确的值，可以将SonarQube身份验证和授权配置到LDAP服务器(包括Active Directory的LDAP服务)。
主要特点是:
（1） 针对外部身份验证引擎进行密码检查。
（2） 自动同步用户名和电子邮件。
（3） 用户和组之间关系的自动同步(授权)。
（4） 能够根据外部和内部身份验证系统进行身份验证。如果LDAP服务器关闭，SonarQube内部系统会自动回退。
（5） 在第一次身份验证试验期间，如果用户的密码正确，SonarQube数据库将自动填充新用户。每次用户登录SonarQube时，在SonarQube数据库中刷新的用户名、电子邮件和用户所属的组。您也可以选择同步组成员关系，但这不是默认值。
    Apache DS   OpenLDAP    Open DS Active Directory
Anonymous   √   √   √   
Simple  √   √   √   √
LDAPS   √   √       √
LDAPS   √       √   √
CRAM-MD5    √       √   √
GSSAPI  √           
√ 表示已测试成功

##### 8.3.2.1 设置
（1）通过编辑$SONARQUBE-HOME/conf/sonar配置LDAP插件。属性(见下表)
（2）重启SonarQube服务器，检查日志文件:
INFO org.sonar.INFO Security realm: LDAP ...
INFO o.s.p.l.LdapContextFactory Test LDAP connection: OK
（3） 登录SonarQube
（4） 登出时，将向用户显示一个登录页面(/sessions/login)，用户可以通过传递适当的凭证选择作为技术用户或域用户登录
对于sonarscanner，我们建议使用本地技术用户对SonarQube服务器进行身份验证。

##### 8.3.2.2 基本设置
Property    Description Default value   Required    Example
sonar.security.realm    将此设置为LDAP，首先根据外部系统进行身份验证。如果外部系统不可用，或者用户没有在外部系统中定义，那么将对SonarQube的内部数据库执行身份验证。    none    Yes LDAP (only possible value)
sonar.authenticator.downcase    当使用不区分大小写的设置连接LDAP服务器时，将其设置为true。   false   No  
ldap.url    LDAP服务器的URL。如果您正在使用ldap，则应该将服务器证书安装到Java信任存储中。  none    Yes ldap://localhost:10389
ldap.bindDn 要连接(或绑定)的LDAP用户的用户名。将此留空，以便匿名访问LDAP目录。  none    No  cn=sonar,ou=users,o=mycompany
ldap.bindPassword   要连接的用户的密码。将此留空，以便匿名访问LDAP目录。    none    No  secret
ldap.authentication 可能的值:simple, CRAM-MD5, DIGEST-MD5, GSSAPI。请参阅有关身份验证机制的教程    simple  No  
ldap.realm  参见Digest-MD5身份验证、cramm - md5身份验证    none    No  example.org
ldap.contextFactoryClass    上下文工厂类。 com.sun.jndi.ldap.LdapCtxFactory    No  
ldap.StartTLS   启用StartTLS  false   No  
ldap.followReferrals    不管是否遵循推荐。请参阅JNDI中的引用
true        

##### 8.3.2.3 用户地图
Property    Description Default value   Required    Example for Active Directory
ldap.user.baseDn    用于搜索用户的LDAP中根节点的专有名称(DN)。   None    Yes cn=users,dc=example,dc=org
ldap.user.request   LDAP用户请求。   (&(objectClass=inetOrgPerson)(uid={login})) No  (&(objectClass=user)(sAMAccountName={login}))
ldap.user.realNameAttribute 属性定义用户的真实名称。    cn  No  
ldap.user.emailAttribute    属性定义用户的电子邮件。    mail    No  
只支持组映射(不支持角色)。只支持静态组(不支持动态组)。
配置组映射时(i。e以下ldap.group。， LDAP服务器中的成员关系将覆盖SonarQube中本地配置的任何成员关系。LDAP服务器成为惟一一个管理组成员关系的地方(并且在每次用户登录时获取信息)。
对于授权授权，必须首先在SonarQube中定义组。然后，必须定义以下属性，以允许SonarQube自动同步用户和组之间的关系。
Property    Description Default value   Required    Example for Active Directory
ldap.group.baseDn   LDAP中根节点的专有名称(DN)，用于从中搜索组。  none    No  cn=groups,dc=example,dc=org
ldap.group.request  LDAP组的请求。   (&(objectClass=groupOfUniqueNames)(uniqueMember={dn}))  No  (&(objectClass=group)(member={dn}))
ldap.group.idAttribute  属性，用于指定用于在兼容模式下返回用户组列表的属性。  cn  No  sAMAccountName

##### 8.3.2.4 配置示例
# LDAP configuration
# General Configuration
sonar.security.realm=LDAP
ldap.url=ldap://myserver.mycompany.com
ldap.bindDn=my_bind_dn
ldap.bindPassword=my_bind_password
  
# User Configuration
ldap.user.baseDn=ou=Users,dc=mycompany,dc=com
ldap.user.request=(&(objectClass=inetOrgPerson)(uid={login}))
ldap.user.realNameAttribute=cn
ldap.user.emailAttribute=mail
 
# Group Configuration
ldap.group.baseDn=ou=Groups,dc=sonarsource,dc=com
ldap.group.request=(&(objectClass=posixGroup)(memberUid={uid}))

#### 8.3.3 高级LDAP的话题
##### 8.3.3.1 认证方式
（1）Anonymous匿名——当绑定到LDAP服务器时，只需要对非受保护的条目和属性进行只读访问时使用。
（2）simple-对于不使用ldaps安全协议的生产部署，不推荐使用简单身份验证，因为它通过网络发送明文密码。
（3）CRAM-MD5 - 基于HMAC-MD5 MAC算法(RFC 2195)的挑战-响应认证方法(CRAM)。
（4）DIGEST-MD5 - 这是对cramm - md5身份验证方法(RFC 2831)的改进。
（5）GSSAPI - GSS-API是通用的安全服务API (RFC 2744)。GSS-API中最流行的安全服务之一是Kerberos v5，它在Microsoft的Windows 2000平台中使用。
有关LDAP身份验证方法的详细讨论，请参见RFC 2829和RFC 2251。

##### 8.3.3.2 多个服务器
配置多个服务器:
# List the different servers
ldap.servers=server1,server2
  
# Configure server1
ldap.server1.url=ldap://server1:1389
ldap.server1.user.baseDn=dc=dept1,dc=com
...
 
# Configure server2
ldap.server2.url=ldap://server2:1389
ldap.server2.user.baseDn=dc=dept2,dc=com
...
在每台服务器上都将按照配置中列出的顺序进行身份验证，直到成功为止。将对找到用户的第一个服务器执行用户/组映射。
注意，在(重新)启动SonarQube服务器时，所有LDAP服务器都必须可用。

##### 8.3.3.3 故障排除
（1）详细的连接日志(以及从LDAP服务器接收到的潜在错误代码)输出到SonarQube的$SONARQUBEHOME/logs/web。log_，当日志记录处于调试模式时。
（2）使用LDAP Java参数运行SonarQube分析时超时的记录如下:http://docs.oracle.com/javase/jndi/tutorial/ldap/connect/config.html。这些参数可以在$SONARQUBE-HOME/conf/sonar.properties文件中的sonar.web.javaAdditionalOpts进行设置。
（3）Kerberos故障诊断资源
    a) 启用Kerberos日志
    b) 故障排除Kerberos授权
（4）排除NTLM的故障
    a)开启NTLM日志

#### 8.3.4 通过其他系统进行身份验证
此外，有几个插件可以允许委托给其他提供商:
Crowd - SonarQube Crowd Plugin
GitHub - GitHub Authentication Plugin
Bitbucket - Bitbucket Authentication Plugin

### 8.4 GitHub企业集成
GitHub企业集成是Developer Edition及以上版本的一部分。

### 8.5 界面外观
#### 8.5.1 主页logo
您可以设置自己的“家”标志在管理>一般>的外观和感觉。只需提供一个图像URL和宽度。理想情况下，宽度会将高度缩放到30像素。此徽标将同时用于菜单栏和About页面。

#### 8.5.2 “关于”页面的内容
您还可以向About页面添加内容，这是匿名用户默认访问的页面:Administration > General > Look & Feel。

#### 8.5.3 Gravatar
默认情况下，使用gravatar.com启用了对Gravatar的支持。您可以配置不同的服务器，或者完全禁用该特性。当启用时，gravatars会显示在用户名的大多数用法旁边。

### 8.6 应用市场
管理员可以通过管理>市场访问市场。市场是让SonarQube平台的各个部分保持最新的地方。它可以让您:
看到：
（1） 当前安装的SonarQube版本
（2） 安装了哪些插件
（3） 插件更新是否可用
（4） 还有哪些插件与您的SonarQube版本兼容
发现：
（1） 还有哪些版本可以提供更多的功能
安装：
（1） 新插件
（2） 插件更新
要查看/安装插件更新，您的SonarQube服务器需要internet访问。安装要求在生效之前重新启动平台。

#### 8.6.1 等待操作
当您在Markplace中执行操作(安装、更新或卸载插件)时，页面顶部会出现一个黄色横幅，显示SonarQube重新启动后将执行的挂起操作。挂起的操作可以被取消，直到服务器重新启动。

#### 8.6.2 重启SonarQube
通过运行sonar.sh restart或直接从UI:
（1） 在更新中心中，当您有挂起的更改时，restart按钮将显示在黄色横幅中(参见挂起的操作)
（2） 在任何时候的系统信息页面

#### 8.6.3 手动更新
如果您的服务器无法访问internet，您将无法依赖市场来获得插件，并且必须手动处理插件安装和升级。
要查看有哪些插件可用，以及哪个版本的插件适合您的服务器，请使用插件版本矩阵，该矩阵与插件的可用性和兼容性保持同步。
要安装插件，只需使用插件文档页面上的手动下载链接下载它，将它放在$SONARQUBEHOME/extensions/downloads_中，然后重启服务器。

#### 8.6.4 市场连接到哪些url
SonarQube市场连接到https://update.sonarsource.org/以获得插件列表。大部分被引用的插件都是从以下网站下载的:
https://binaries.sonarsource.com/
https://github.com/

#### 8.6.5 通过代理连接应用市场
Marketplace使用HTTP(S)连接到外部服务器来提供这些服务。如果SonarQube位于代理之后，则必须在$ SonarQube - home /conf/sonar中提供附加信息。属性配置文件:
http.proxyHost=<your.proxy.host>
http.proxyPort=<yout.proxy.port>

#If proxy authentication is required
http.proxyUser=<your.proxy.user>
http.proxyPassword=<your.proxy.password>
注意:在https中也可以使用相同的属性。'用于HTTPS连接的表单。

### 8.7 Housekeeping
当您运行对您的项目或其分支或pull requests(PRs)的新分析时，以前可用的一些数据将从数据库中清除。例如，前面分析的源代码、目录和文件级别上的度量，等等都会在新的分析结束时自动删除。此外，还删除了一些旧的分析快照、PR分析和分支。
为什么?经常分析一个项目，看看它的质量如何发展，这是很有用的。能够看到几周、几个月、几年的趋势也很有用。但是当您回顾过去时，您并不需要与项目当前状态相同的详细级别。为了节省空间和提高整体性能，数据库清理器删除了数据库中的一些行。这是它的默认配置:
（1） 为每个项目:
a)  每天只有一个快照在1天后保存。不会删除由事件标记的快照。
b)  一个月后，每周只保留一张快照。不会删除由事件标记的快照。
c)  1年后，每个月只保留一个快照。不会删除由事件标记的快照。
d)  只有带有版本事件的快照才会在两年后保存。没有事件或只有其他事件类型的快照将被删除。
e)  删除所有大于5年的快照，包括由事件标记的快照。
（2） 所有30天以上的已关闭问题将被删除
（3） 删除包/目录级别的历史记录
这些设置可以在管理>通用>数据库清理程序中更改。

### 8.8 通知
在每次分析结束时，将为每个订阅的用户计算通知。然后，通过电子邮件异步发送这些通知。
要设置处理通知队列的频率，请在$SONARQUBE-HOME/conf/sonar.properties中设置sonar.notification .delay属性(以秒为单位)。必须重新启动服务器，才能考虑新值。

#### 8.8.1 哪些人可以收到通知
只有订阅自己的用户才会收到通知。只有一个例外，没有主动订阅其他用户的管理功能。如果你认为用户应该收到通知，那么是时候练习温和的说服技巧了。
异常
当内置的质量配置文件被更新时，通知将自动发送给具有质量配置文件管理权限的用户(没有用户选择)。这些更新只能通过相关分析器的升级来实现。这种类型的通知在默认情况下是打开的，并且可以在管理>通用设置>通用中全局切换。

#### 8.8.2 电子邮件配置
要配置电子邮件服务器，请转到管理>一般设置>电子邮件。
还要检查Administration > General Settings > General中的服务器基本URL属性，以确保这些通知电子邮件中的链接将重定向到正确的SonarQube服务器URL。

### 8.9 服务器日志和系统信息
系统信息页面位于Administration >System。它允许您访问关于SonarQube实例状态的详细信息。

#### 8.9.1 系统信息
您可以在此页面上浏览有关正在运行的实例的详细信息。
（1） 下载
此外，如果您有一个支持合同，您可能会被支持代表要求发送您的系统信息，您可以使用顶部的“Download System Info”按钮从页面管理>系统下载系统信息。
（2） 服务ID
通过展开System部分，可以从这个页面获得服务器id。如果您正在运行一个商业实例，您还可以在License页面上找到这个值(Administration > Configuration > License Manager)

#### 8.9.2 日志
服务器端日志由$SONARQUBE-HOME/conf/sonar.properties中设置的属性控制。
创建4个日志文件:每个SonarQube进程一个日志文件。
（1） 日志级别
服务器端日志级别可以通过sonar.log定制。级别属性。支持的值是:
a）  INFO – 默认级别
b）  DEBUG - 对于高级日志。
c）  TRACE - 显示高级日志和所有SQL和Elasticsearch请求。跟踪级别日志降低了服务器环境的速度，应该只用于跟踪web请求性能问题。
（2） 按进程划分的日志级别
通过以下属性，可以更精确地调整SonarQube服务器的4个进程的服务器端日志级别:
a)  sonar.log.level.app – 对于SonarQube的主进程(也称为WrapperSimpleApp，启动其他3个进程的引导程序)
b)  sonar.log.level.web – 设置web服务
c)  sonar.log.level.ce – 设置计算引擎服务
d)  sonar.log.level.es – 设置搜索引擎
（3） 日志迭代
要控制日志滚动，请使用sonar.log.rollingPolicy
a)  time:[value] - 基于时间的旋转。例如，使用time:yyyy-MM-dd用于每日旋转，*time:yyyy-MM用于每月旋转。
b)  size:[value] -基于对大小的旋转。例如,size:10MB。
c)  none - 没有旋转。通常，当日志由外部系统(如logrotate)处理时，将使用这种方法。
sonar.log.maxFiles是要保存的文件的最大数量。如果sonar.log.rollingPolicy=none，则忽略此属性。
（4） UI访问日志和日志级别
系统信息页面使您能够下载实例的当前日志文件(日志文件定期旋转)，并通过页面顶部的控件调整日志级别。这里所做的更改是临时的，并且只持续到下一次重新启动实例时，此时级别将重置为$SONARQUBE-HOME/conf/sonar.properties中设置的更持久的值。无论如何，如果您改变您的日志级别从信息，但一定要改变它回来尽快是可行的;在较低的日志级别，日志文件可以很快变得非常大。

#### 8.9.3 代码总行数
（1）SonarQube 6.7 LTS及以上版本
实例中的代码行数(用于许可目的)可以在系统信息页面的系统部分找到，也可以在许可页面上找到(商业版本中的管理>配置>许可管理器)。
如果您使用的是商业版本，并且使用分支或PR分析，请放心，出于许可的目的，只考虑项目中单个最大分支中的行。其余分支中的代码行将被忽略。
（2）6.7版本之前较老的版本
最好的方法是查询数据库。实际查询根据SonarQube版本和数据库引擎的不同而有所不同。提供两个查询:
一个查询计算所有项目的LOCs &一个查询过滤掉项目分支(即使用sonar分析的项目)。分支参数)。但是，只有在有分支的项目在没有sonar.branch的情况下也分析一次时，这个查询才准确。
（3）SonarQube LTS v5.6.x
MySQL
全局LOCs
select sum(pm.value) as global_loc from projects p
inner join snapshots s on s.project_id = p.id
inner join project_measures pm on pm.snapshot_id = s.id
inner join metrics m on m.id=pm.metric_id
where s.islast = true
and p.enabled = true
and p.qualifier = 'TRK'
and p.scope = 'PRJ'
and p.copy_resource_id is null
and pm.person_id is null
and m.name='ncloc';
LOCs没有sonar.branch
select sum(pm.value) as loc_without_branch from projects p
inner join snapshots s on s.project_id = p.id
inner join project_measures pm on pm.snapshot_id = s.id
inner join metrics m on m.id=pm.metric_id
where s.islast = true
and p.enabled = true
and p.qualifier = 'TRK'
and p.scope = 'PRJ'
and p.copy_resource_id is null
and pm.person_id is null
and m.name='ncloc'
and (
INSTR(p.kee, ':') = 0 or not exists(
select * from projects p_root where p_root.kee = SUBSTR(p.kee, 1, LENGTH(p.kee) - INSTR(REVERSE(p.kee), ':'))
));

PostgreSQL 8.0-9.0
全局LOCs
select sum(pm.value) as global_loc from projects p
inner join snapshots s on s.project_id = p.id
inner join project_measures pm on pm.snapshot_id = s.id
inner join metrics m on m.id=pm.metric_id
where s.islast = true
and p.enabled = true
and p.qualifier = 'TRK'
and p.scope = 'PRJ'
and p.copy_resource_id is null
and pm.person_id is null
and m.name='ncloc';
LOCs没有sonar.branch在这个指定的数据库上不可行。

PostgreSQL 9.1+
全局LOCs
select sum(pm.value) as global_loc from projects p
inner join snapshots s on s.project_id = p.id
inner join project_measures pm on pm.snapshot_id = s.id
inner join metrics m on m.id=pm.metric_id
where s.islast = true
and p.enabled = true
and p.qualifier = 'TRK'
and p.scope = 'PRJ'
and p.copy_resource_id is null
and pm.person_id is null
and m.name='ncloc';
LOCs没有sonar.branch
select sum(pm.value) as loc_without_branch from projects p
inner join snapshots s on s.project_id = p.id
inner join project_measures pm on pm.snapshot_id = s.id
inner join metrics m on m.id=pm.metric_id
where s.islast = true
and p.enabled = true
and p.qualifier = 'TRK'
and p.scope = 'PRJ'
and p.copy_resource_id is null
and pm.person_id is null
and m.name='ncloc'
and (
POSITION(':' IN p.kee) = 0 or not exists(
select * from projects p_root where p_root.kee = SUBSTRING(p.kee, 0, LENGTH(p.kee) - POSITION(':' in REVERSE(p.kee)) + 1)
));

Oracle
全局LOCs
select sum(pm.value) as global_loc from projects p
inner join snapshots s on s.project_id = p.id
inner join project_measures pm on pm.snapshot_id = s.id
inner join metrics m on m.id=pm.metric_id
where s.islast = 1
and p.enabled = 1
and p.qualifier = 'TRK'
and p.scope = 'PRJ'
and p.copy_resource_id is null
and pm.person_id is null
and m.name='ncloc';
LOCs没有sonar.branch
select sum(pm.value) as loc_without_branch from projects p
inner join snapshots s on s.project_id = p.id
inner join project_measures pm on pm.snapshot_id = s.id
inner join metrics m on m.id=pm.metric_id
where s.islast = 1
and p.enabled = 1
and p.qualifier = 'TRK'
and p.scope = 'PRJ'
and p.copy_resource_id is null
and pm.person_id is null
and m.name='ncloc'
and (
INSTR(p.kee, ':') = 0 or not exists(
select * from projects p_root where p_root.kee = SUBSTR(p.kee, 0, INSTR(p.kee, ':', -1) - 1)
));

Microsoft SQL Server (a.k.a MSSQL)
全局LOCs
select sum(pm.value) as global_loc from projects p
inner join snapshots s on s.project_id = p.id
inner join project_measures pm on pm.snapshot_id = s.id
inner join metrics m on m.id=pm.metric_id
where s.islast = 1
and p.enabled = 1
and p.qualifier = 'TRK'
and p.scope = 'PRJ'
and p.copy_resource_id is null
and pm.person_id is null
and m.name='ncloc';
LOCs没有sonar.branch
select sum(pm.value) as loc_without_branch from projects p
inner join snapshots s on s.project_id = p.id
inner join project_measures pm on pm.snapshot_id = s.id
inner join metrics m on m.id=pm.metric_id
where s.islast = 1
and p.enabled = 1
and p.qualifier = 'TRK'
and p.scope = 'PRJ'
and p.copy_resource_id is null
and pm.person_id is null
and m.name='ncloc'
and (
CHARINDEX(':', p.kee) = 0 or not exists(
select * from projects p_root where p_root.kee = SUBSTRING(p.kee, 0, LEN(p.kee) - CHARINDEX(':', REVERSE(p.kee)) + 1 )
));

（4）SonarQube 6.0-6.6
MySQL
全局LOCs
select sum(pm.value) as global_loc from projects p
inner join snapshots s on s.component_uuid = p.uuid
inner join project_measures pm on pm.analysis_uuid = s.uuid
inner join metrics m on m.id=pm.metric_id
where s.islast = true
and p.enabled = true
and p.qualifier = 'TRK'
and p.scope = 'PRJ'
and p.copy_component_uuid is null
and pm.component_uuid = p.uuid
and pm.person_id is null
and m.name='ncloc';
LOCs没有sonar.branch
select sum(pm.value) as loc_without_branch from projects p
inner join snapshots s on s.component_uuid = p.uuid
inner join project_measures pm on pm.analysis_uuid = s.uuid
inner join metrics m on m.id=pm.metric_id
where s.islast = true
and p.enabled = true
and p.qualifier = 'TRK'
and p.scope = 'PRJ'
and p.copy_component_uuid is null
and pm.component_uuid = p.uuid
and pm.person_id is null
and m.name='ncloc'
and (
INSTR(p.kee, ':') = 0 or not exists(
select * from projects p_root where p_root.kee = SUBSTR(p.kee, 1, LENGTH(p.kee) - INSTR(REVERSE(p.kee), ':'))
));

PostgreSQL 8.0-9.0
全局LOCs
select sum(pm.value) as global_loc from projects p
inner join snapshots s on s.component_uuid = p.uuid
inner join project_measures pm on pm.analysis_uuid = s.uuid
inner join metrics m on m.id=pm.metric_id
where s.islast = true
and p.enabled = true
and p.qualifier = 'TRK'
and p.scope = 'PRJ'
and p.copy_component_uuid is null
and pm.component_uuid = p.uuid
and pm.person_id is null
and m.name='ncloc';
LOCs没有sonar.branch在这个指定的数据库上不可行。

PostgreSQL 9.1+
全局LOCs
select sum(pm.value) as global_loc from projects p
inner join snapshots s on s.component_uuid = p.uuid
inner join project_measures pm on pm.analysis_uuid = s.uuid
inner join metrics m on m.id=pm.metric_id
where s.islast = true
and p.enabled = true
and p.qualifier = 'TRK'
and p.scope = 'PRJ'
and p.copy_component_uuid is null
and pm.component_uuid = p.uuid
and pm.person_id is null
and m.name='ncloc';
LOCs没有sonar.branch
select sum(pm.value) as loc_without_branch from projects p
inner join snapshots s on s.component_uuid = p.uuid
inner join project_measures pm on pm.analysis_uuid = s.uuid
inner join metrics m on m.id=pm.metric_id
where s.islast = true
and p.enabled = true
and p.qualifier = 'TRK'
and p.scope = 'PRJ'
and p.copy_component_uuid is null
and pm.component_uuid = p.uuid
and pm.person_id is null
and m.name='ncloc' and (
POSITION(':' IN p.kee) = 0 or not exists(
select * from projects p_root where p_root.kee = SUBSTRING(p.kee, 0, LENGTH(p.kee) - POSITION(':' in REVERSE(p.kee)) + 1)
));

Oracle
全局LOCs
select sum(pm.value) as global_loc from projects p
inner join snapshots s on s.component_uuid = p.uuid
inner join project_measures pm on pm.analysis_uuid = s.uuid
inner join metrics m on m.id=pm.metric_id
where s.islast = 1
and p.enabled = 1
and p.qualifier = 'TRK'
and p.scope = 'PRJ'
and p.copy_component_uuid is null
and pm.component_uuid = p.uuid
and pm.person_id is null
and m.name='ncloc';
LOCs没有sonar.branch
select sum(pm.value) as loc_without_branch from projects p
inner join snapshots s on s.component_uuid = p.uuid
inner join project_measures pm on pm.analysis_uuid = s.uuid
inner join metrics m on m.id=pm.metric_id
where s.islast = 1
and p.enabled = 1
and p.qualifier = 'TRK'
and p.scope = 'PRJ'
and p.copy_component_uuid is null
and pm.component_uuid = p.uuid
and pm.person_id is null
and m.name='ncloc' 
and (
INSTR(p.kee, ':') = 0 or not exists(
select * from projects p_root where p_root.kee = SUBSTR(p.kee, 0, INSTR(p.kee, ':', -1) - 1)
));

Microsoft SQL Server (a.k.a MSSQL)
全局LOCs
select sum(pm.value) as global_loc from projects p
inner join snapshots s on s.component_uuid = p.uuid
inner join project_measures pm on pm.analysis_uuid = s.uuid
inner join metrics m on m.id=pm.metric_id
where s.islast = 1
and p.enabled = 1
and p.qualifier = 'TRK'
and p.scope = 'PRJ'
and p.copy_component_uuid is null
and pm.component_uuid = p.uuid
and pm.person_id is null
and m.name='ncloc';
LOCs没有sonar.branch
select sum(pm.value) as loc_without_branch from projects p
inner join snapshots s on s.component_uuid = p.uuid
inner join project_measures pm on pm.analysis_uuid = s.uuid
inner join metrics m on m.id=pm.metric_id
where s.islast = 1
and p.enabled = 1
and p.qualifier = 'TRK'
and p.scope = 'PRJ'
and p.copy_component_uuid is null
and pm.component_uuid = p.uuid
and pm.person_id is null
and m.name='ncloc' 
and (
CHARINDEX(':', p.kee) = 0 or not exists(
select * from projects p_root where p_root.kee = SUBSTRING(p.kee, 0, LEN(p.kee) - CHARINDEX(':', REVERSE(p.kee)) + 1 )
));

### 8.10 监控
监控SonarQube实例是保持其健康和拥有快乐用户的关键。
首先，您可以使用这个Web API来获得SonarQube安装的健康状况概览:
api/system/health

#### 8.10.1 Java进程的内存
SonarQube应用服务器由三个主要的Java进程组成:
（1）Web(包括嵌入式Web服务器
（2）ElasticSearch
（3）Compute Engine
每个Java进程都有自己的内存设置，可以在$SONARQUBE-HOME/conf/sonar中配置。属性文件。SonarQube附带的默认内存设置在大多数情况下都是可以的。如果你是支持大型SonarQube实例(超过100用户或超过5000000行代码)或一个实例持续集成管道的一部分,您应该监视所有三个关键的内存和CPU使用Java进程实例,以及整体的磁盘空间。监视将允许您查看是否有任何流程资源不足，并在资源短缺之前采取行动。有大量可用的监视工具(开源的和商业的)可以帮助您完成这项任务。SonarSource不推荐或支持任何特定的工具。
#### 8.10.2 内存设置
你可能需要增加你的记忆设置，如果你看到以下症状:
（1） 您的监视工具显示一个或多个SonarQube进程达到了内存限制
（2） 任何SonarQube进程崩溃并/或在sonar.log文件中生成内存不足错误
（3） SonarQube后台任务失败，后台任务日志中出现内存不足错误
（4） ElasticSearch实例的问题索引(在系统信息中可见)的大小大于或等于分配给ElasticSearch Java进程的内存
通过在$SONARQUBE-HOME/conf/sonar.properties中增加对应Java进程的-Xmx内存设置，可以增加分配给适当进程的最大内存：
（1） Web服务：sonar.web.javaOpts
（2） ElasticSearch服务：sonar.search.javaOpts
（3） Compute Engine服务：sonar.ce.javaOpts
-Xmx参数同时接受兆字节(例如-Xmx2048m)和千兆字节(例如-Xmx2G)的数字。
有关SonarQube公开的JMX bean的详细信息和更多的ElasticSearch监视选项，请访问我们的监视详细信息页面。

#### 8.10.3 对外的JMX MBeans
SonarQube服务器通过公开JMX mbean提供了关于内部发生的事情的可见性。
除了经典的Java mbean提供关于类加载器、OS、内存和线程的信息外，您还可以访问SonarQube服务器中的另外四个mbean:
（1） ComputeEngine
（2） Database
（3） SonarQube
所有这些mbean都是只读的。不可能实时修改或重置它们的值。

#### 8.10.4 ComputeEngineTasks MBean
属性名称    描述
ProcessingTime  测量自上次重新启动SonarQube以来用于处理后台任务的时间(以ms为单位)。它的值将始终增加，并将通过重新启动SonarQube重置。当与SuccessCount和ErrorCount度量相结合以获得处理后台任务的平均时间，或者用于了解SonarQube服务器在一天中花了多少时间来处理后台任务时，此度量非常强大。它会显示服务器上的负载。
ErrorCount  自上次重新启动SonarQube以来失败的后台任务数量
PendingCount    自上次重新启动SonarQube以来，等待处理的后台任务数量
InProgressCount 当前正在处理的后台任务数量。它的值为1或0，因为SonarQube一次只能处理一个任务。
SuccessCount    自上次重新启动SonarQube以来，成功处理的后台任务数量
WorkerCount 可以同时处理的后台任务的数量
注意：
（1） 自上次重新启动SonarQube以来处理的后台任务总数等于SuccessCount + ErrorCount
（2） 通过重新启动SonarQube，可以将这些值重置为默认值

#### 8.10.5数据库MBean
ComputeEngineServer和WebServer都具有相同的属性。
属性名称    描述
MigrationStatus 可能的值是:UPTODATE、REQUIRESUPGRADE、requires降级、FRESH_INSTALL(仅适用于WebServer)。
PoolActiveConnections   活动数据库连接的数量
PoolIdleConnections 等待使用的数据库连接数
PoolInitialSize 数据库连接池的初始大小。
PoolMaxActiveConnections    活动数据库连接的最大数量
PoolMaxIdleConnections  等待使用的数据库连接的最大数量
PoolMaxWaitMillis   以毫秒为单位
PoolRemoveAbandoned 可能的值:true、false
PoolRemoveAbandonedTimeoutSeconds   以秒为单位

#### 8.10.6 SonarQube MBean
属性名称    描述
LogLevel    日志级别; INFO, DEBUG, TRACE
ServerId    SonarQube服务器ID
Version SonarQube版本

#### 8.10.7 激活JMX
本地访问
如果您的工具运行在与SonarQube服务器相同的服务器上，则不需要激活任何程序来查看SonarQube mbean。
远程访问
下面是激活对JMX mbean的远程访问的配置示例。
Web服务：
# JMX WEB - 10443/10444
sonar.web.javaAdditionalOpts=-Dcom.sun.management.jmxremote=true -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=true -Dcom.sun.management.jmxremote.port=10443 -Dcom.sun.management.jmxremote.rmi.port=10444 -Dcom.sun.management.jmxremote.password.file=/opt/sonarsource/sonar/conf/jmxremote.password -Dcom.sun.management.jmxremote.access.file=/opt/sonarsource/sonar/conf/jmxremote.access
ComputeEngine:
没有特定的javaAdditionalOpts条目，只需修改sonar.ce.javaOpts这一个即可。
jmxremote.access示例：
#
# JMX Access Control file
#
reader readonly
admin  readwrite \
    create javax.management.monitor.*,javax.management.timer.*,com.sun.management.*,com.oracle.jrockit.* \
    unregister
jmxremote.password 示例：
#
# JMX Access Password file
#
reader readerpassword
admin  adminpassword
注意：应该通过chmod 600或者400给jmxremote.password设置权限以保证安全性。

### 8.11 项目迁移
Project Move是Enterprise Edition或以上版本的一部分。
Project Move允许您从一个SonarQube实例导出一个项目，并将其导入到另一个相同配置的SonarQube实例中。要使用Project Move，您必须对源实例中的项目拥有管理员权限，并访问这两个实例的文件系统。

### 8.12 自定义措施
SonarQube以自动化的方式收集度量的最大值，但是有些度量是不可能做到这一点的，例如:何时:信息不可收集，度量由人工计算，等等。不管是什么原因，SonarQube提供了一个服务来手动注入这些度量，并允许您从其他服务中获益:手动度量服务。所输入的手工措施将在项目的下一次分析中选定，然后作为“正常”措施处理。
#### 8.12.1 管理自定义指标
与自动收集的度量一样，手动度量是每个分析中为手动度量收集的值。因此，要做的第一件事是创建要保存度量的度量。为此，作为系统管理员登录到Administration > Configuration > Custom Metrics，该接口将指导您创建所需的度量。
#### 8.12.2 管理自定义措施
可以在项目级别输入自定义度量。要添加度量，作为项目管理员登录，导航到所需的项目，并选择Administration > Custom度量，您将在其中找到一个表，其中为每个度量输入了最新的度量值。
在这个接口中输入的值是“挂起的”，在下一次分析之前，在这个管理接口之外是不可见的。

### 8.13 计算引擎的性能
管理计算引擎性能的能力是企业版或以上版本的一部分。

### 8.14 SonarQube数据库复制工具
SonarQube DB复制工具可用于Enterprise Edition及以上客户。

## 9 常见问答（FAQ）
### 9.1 我如何摆脱假阳性的问题?
（1）假阳性，无需修复
您可以通过problems接口将个别问题标记为False Positive或Won'特不修复。如果您使用的是开发人员版提供的短期分支和PR分析，那么标记为False Positive或Won' d Fix的问题将在合并后保留该状态。这是首选的方法。
（2）//NOSONAR
大多数语言分析器都支持在问题的末尾使用泛型机制://NOSONAR。这将压制所有现在和将来可能在这个问题上提出的问题。

### 9.2 如何查找和删除一段时间没有分析的项目?
在Administration > Projects > Management中，您可以搜索之前的最后一次分析来过滤自特定日期以来未分析的项目，然后使用批量删除来删除匹配您的筛选器的项目。
这可以通过使用相应的Web API实现自动化:API /projects/bulk_delete?analyzedBefore=YYYY-MM-DD。

### 9.3 如何触发一个完整的ElasticSearch重建索引?
目前，强制重新索引的唯一方法是:
（1） 停服务
（2） 删除$SQ_HOME/data/es5目录的内容
（3） 起服务
在执行此操作之前，您应该首先知道SonarQube端上的进程已经就绪，将检测并纠正不同步的索引;其次，根据实例的大小，完整的重新索引可能非常长。

### 9.4 为什么我不能使用我的HTTP代理，因为我升级到Java8u111?
如果您在尝试使用市场时在日志中出现此错误:
java.io.IOException: Unable to tunnel through proxy. Proxy returns "HTTP/1.1 407 Proxy Authentication Required
…您可能使用大于111的更新升级了Java8安装。要解决这个问题，请更新$SONARQUBEHOME/conf/sonar.properties”像这样的:
sonar.web.javaOpts=-Xmx512m -Xms128m -XX:+HeapDumpOnOutOfMemoryError -Djdk.http.auth.tunneling.disabledSchemes=""
参考：http://www.oracle.com/technetwork/java/javase/8u111-relnotes-3124969.html






